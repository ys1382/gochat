/// Generated by the Protocol Buffers 3.3.0 compiler.  DO NOT EDIT!
/// Protobuf-swift version: 3.0.16
/// Source file "wire.proto"
/// Syntax "Proto3"

import Foundation
import ProtocolBuffers


public struct WireRoot {
    public static let `default` = WireRoot()
    public var extensionRegistry:ExtensionRegistry

    init() {
        extensionRegistry = ExtensionRegistry()
        registerAllExtensions(registry: extensionRegistry)
    }
    public func registerAllExtensions(registry: ExtensionRegistry) {
    }
}

final public class Login : GeneratedMessage {

    public static func == (lhs: Login, rhs: Login) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasUsername == rhs.hasUsername) && (!lhs.hasUsername || lhs.username == rhs.username)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var username:String! = nil
    public fileprivate(set) var hasUsername:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasUsername {
            try codedOutputStream.writeString(fieldNumber: 1, value:username)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasUsername {
            serialize_size += username.computeStringSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Login.Builder {
        return Login.classBuilder() as! Login.Builder
    }
    public func getBuilder() -> Login.Builder {
        return classBuilder() as! Login.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Login.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Login.Builder()
    }
    public func toBuilder() throws -> Login.Builder {
        return try Login.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Login) throws -> Login.Builder {
        return try Login.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasUsername {
            jsonMap["username"] = username
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Login {
        return try Login.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Login {
        return try Login.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasUsername {
            output += "\(indent) username: \(username) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasUsername {
                hashCode = (hashCode &* 31) &+ username.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Login"
    }
    override public func className() -> String {
        return "Login"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Login = Login()
        public func getMessage() -> Login {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var username:String {
            get {
                return builderResult.username
            }
            set (value) {
                builderResult.hasUsername = true
                builderResult.username = value
            }
        }
        public var hasUsername:Bool {
            get {
                return builderResult.hasUsername
            }
        }
        @discardableResult
        public func setUsername(_ value:String) -> Login.Builder {
            self.username = value
            return self
        }
        @discardableResult
        public func clearUsername() -> Login.Builder{
            builderResult.hasUsername = false
            builderResult.username = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Login.Builder {
            builderResult = Login()
            return self
        }
        override public func clone() throws -> Login.Builder {
            return try Login.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Login {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Login {
            let returnMe:Login = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Login) throws -> Login.Builder {
            if other == Login() {
                return self
            }
            if other.hasUsername {
                username = other.username
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Login.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Login.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    username = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Login.Builder {
            let resultDecodedBuilder = Login.Builder()
            if let jsonValueUsername = jsonMap["username"] as? String {
                resultDecodedBuilder.username = jsonValueUsername
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Login.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Login.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Contact : GeneratedMessage {

    public static func == (lhs: Contact, rhs: Contact) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasName == rhs.hasName) && (!lhs.hasName || lhs.name == rhs.name)
        fieldCheck = fieldCheck && (lhs.hasOnline == rhs.hasOnline) && (!lhs.hasOnline || lhs.online == rhs.online)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var name:String! = nil
    public fileprivate(set) var hasName:Bool = false

    public fileprivate(set) var online:Bool! = nil
    public fileprivate(set) var hasOnline:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasName {
            try codedOutputStream.writeString(fieldNumber: 1, value:name)
        }
        if hasOnline {
            try codedOutputStream.writeBool(fieldNumber: 2, value:online)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasName {
            serialize_size += name.computeStringSize(fieldNumber: 1)
        }
        if hasOnline {
            serialize_size += online.computeBoolSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Contact.Builder {
        return Contact.classBuilder() as! Contact.Builder
    }
    public func getBuilder() -> Contact.Builder {
        return classBuilder() as! Contact.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Contact.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Contact.Builder()
    }
    public func toBuilder() throws -> Contact.Builder {
        return try Contact.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Contact) throws -> Contact.Builder {
        return try Contact.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasName {
            jsonMap["name"] = name
        }
        if hasOnline {
            jsonMap["online"] = online
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Contact {
        return try Contact.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Contact {
        return try Contact.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasName {
            output += "\(indent) name: \(name) \n"
        }
        if hasOnline {
            output += "\(indent) online: \(online) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasName {
                hashCode = (hashCode &* 31) &+ name.hashValue
            }
            if hasOnline {
                hashCode = (hashCode &* 31) &+ online.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Contact"
    }
    override public func className() -> String {
        return "Contact"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Contact = Contact()
        public func getMessage() -> Contact {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var name:String {
            get {
                return builderResult.name
            }
            set (value) {
                builderResult.hasName = true
                builderResult.name = value
            }
        }
        public var hasName:Bool {
            get {
                return builderResult.hasName
            }
        }
        @discardableResult
        public func setName(_ value:String) -> Contact.Builder {
            self.name = value
            return self
        }
        @discardableResult
        public func clearName() -> Contact.Builder{
            builderResult.hasName = false
            builderResult.name = nil
            return self
        }
        public var online:Bool {
            get {
                return builderResult.online
            }
            set (value) {
                builderResult.hasOnline = true
                builderResult.online = value
            }
        }
        public var hasOnline:Bool {
            get {
                return builderResult.hasOnline
            }
        }
        @discardableResult
        public func setOnline(_ value:Bool) -> Contact.Builder {
            self.online = value
            return self
        }
        @discardableResult
        public func clearOnline() -> Contact.Builder{
            builderResult.hasOnline = false
            builderResult.online = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Contact.Builder {
            builderResult = Contact()
            return self
        }
        override public func clone() throws -> Contact.Builder {
            return try Contact.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Contact {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Contact {
            let returnMe:Contact = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Contact) throws -> Contact.Builder {
            if other == Contact() {
                return self
            }
            if other.hasName {
                name = other.name
            }
            if other.hasOnline {
                online = other.online
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Contact.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Contact.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    name = try codedInputStream.readString()

                case 16:
                    online = try codedInputStream.readBool()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Contact.Builder {
            let resultDecodedBuilder = Contact.Builder()
            if let jsonValueName = jsonMap["name"] as? String {
                resultDecodedBuilder.name = jsonValueName
            }
            if let jsonValueOnline = jsonMap["online"] as? Bool {
                resultDecodedBuilder.online = jsonValueOnline
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Contact.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Contact.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Text : GeneratedMessage {

    public static func == (lhs: Text, rhs: Text) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasBody == rhs.hasBody) && (!lhs.hasBody || lhs.body == rhs.body)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var body:String! = nil
    public fileprivate(set) var hasBody:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasBody {
            try codedOutputStream.writeString(fieldNumber: 1, value:body)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasBody {
            serialize_size += body.computeStringSize(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Text.Builder {
        return Text.classBuilder() as! Text.Builder
    }
    public func getBuilder() -> Text.Builder {
        return classBuilder() as! Text.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Text.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Text.Builder()
    }
    public func toBuilder() throws -> Text.Builder {
        return try Text.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Text) throws -> Text.Builder {
        return try Text.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasBody {
            jsonMap["body"] = body
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Text {
        return try Text.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Text {
        return try Text.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasBody {
            output += "\(indent) body: \(body) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasBody {
                hashCode = (hashCode &* 31) &+ body.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Text"
    }
    override public func className() -> String {
        return "Text"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Text = Text()
        public func getMessage() -> Text {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var body:String {
            get {
                return builderResult.body
            }
            set (value) {
                builderResult.hasBody = true
                builderResult.body = value
            }
        }
        public var hasBody:Bool {
            get {
                return builderResult.hasBody
            }
        }
        @discardableResult
        public func setBody(_ value:String) -> Text.Builder {
            self.body = value
            return self
        }
        @discardableResult
        public func clearBody() -> Text.Builder{
            builderResult.hasBody = false
            builderResult.body = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Text.Builder {
            builderResult = Text()
            return self
        }
        override public func clone() throws -> Text.Builder {
            return try Text.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Text {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Text {
            let returnMe:Text = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Text) throws -> Text.Builder {
            if other == Text() {
                return self
            }
            if other.hasBody {
                body = other.body
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Text.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Text.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    body = try codedInputStream.readString()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Text.Builder {
            let resultDecodedBuilder = Text.Builder()
            if let jsonValueBody = jsonMap["body"] as? String {
                resultDecodedBuilder.body = jsonValueBody
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Text.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Text.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class File : GeneratedMessage {

    public static func == (lhs: File, rhs: File) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
        fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var key:String! = nil
    public fileprivate(set) var hasKey:Bool = false

    public fileprivate(set) var data:Data! = nil
    public fileprivate(set) var hasData:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasKey {
            try codedOutputStream.writeString(fieldNumber: 1, value:key)
        }
        if hasData {
            try codedOutputStream.writeData(fieldNumber: 2, value:data)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasKey {
            serialize_size += key.computeStringSize(fieldNumber: 1)
        }
        if hasData {
            serialize_size += data.computeDataSize(fieldNumber: 2)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> File.Builder {
        return File.classBuilder() as! File.Builder
    }
    public func getBuilder() -> File.Builder {
        return classBuilder() as! File.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return File.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return File.Builder()
    }
    public func toBuilder() throws -> File.Builder {
        return try File.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:File) throws -> File.Builder {
        return try File.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasKey {
            jsonMap["key"] = key
        }
        if hasData {
            jsonMap["data"] = data.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> File {
        return try File.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> File {
        return try File.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasKey {
            output += "\(indent) key: \(key) \n"
        }
        if hasData {
            output += "\(indent) data: \(data) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasKey {
                hashCode = (hashCode &* 31) &+ key.hashValue
            }
            if hasData {
                hashCode = (hashCode &* 31) &+ data.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "File"
    }
    override public func className() -> String {
        return "File"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:File = File()
        public func getMessage() -> File {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var key:String {
            get {
                return builderResult.key
            }
            set (value) {
                builderResult.hasKey = true
                builderResult.key = value
            }
        }
        public var hasKey:Bool {
            get {
                return builderResult.hasKey
            }
        }
        @discardableResult
        public func setKey(_ value:String) -> File.Builder {
            self.key = value
            return self
        }
        @discardableResult
        public func clearKey() -> File.Builder{
            builderResult.hasKey = false
            builderResult.key = nil
            return self
        }
        public var data:Data {
            get {
                return builderResult.data
            }
            set (value) {
                builderResult.hasData = true
                builderResult.data = value
            }
        }
        public var hasData:Bool {
            get {
                return builderResult.hasData
            }
        }
        @discardableResult
        public func setData(_ value:Data) -> File.Builder {
            self.data = value
            return self
        }
        @discardableResult
        public func clearData() -> File.Builder{
            builderResult.hasData = false
            builderResult.data = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> File.Builder {
            builderResult = File()
            return self
        }
        override public func clone() throws -> File.Builder {
            return try File.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> File {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> File {
            let returnMe:File = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:File) throws -> File.Builder {
            if other == File() {
                return self
            }
            if other.hasKey {
                key = other.key
            }
            if other.hasData {
                data = other.data
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> File.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> File.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    key = try codedInputStream.readString()

                case 18:
                    data = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> File.Builder {
            let resultDecodedBuilder = File.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
                resultDecodedBuilder.key = jsonValueKey
            }
            if let jsonValueData = jsonMap["data"] as? String {
                resultDecodedBuilder.data = Data(base64Encoded:jsonValueData, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> File.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try File.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Call : GeneratedMessage {

    public static func == (lhs: Call, rhs: Call) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
        fieldCheck = fieldCheck && (lhs.hasTo == rhs.hasTo) && (!lhs.hasTo || lhs.to == rhs.to)
        fieldCheck = fieldCheck && (lhs.hasFrom == rhs.hasFrom) && (!lhs.hasFrom || lhs.from == rhs.from)
        fieldCheck = fieldCheck && (lhs.hasAudio == rhs.hasAudio) && (!lhs.hasAudio || lhs.audio == rhs.audio)
        fieldCheck = fieldCheck && (lhs.hasVideo == rhs.hasVideo) && (!lhs.hasVideo || lhs.video == rhs.video)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var key:String! = nil
    public fileprivate(set) var hasKey:Bool = false

    public fileprivate(set) var to:String! = nil
    public fileprivate(set) var hasTo:Bool = false

    public fileprivate(set) var from:String! = nil
    public fileprivate(set) var hasFrom:Bool = false

    public fileprivate(set) var audio:Bool! = nil
    public fileprivate(set) var hasAudio:Bool = false

    public fileprivate(set) var video:Bool! = nil
    public fileprivate(set) var hasVideo:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasKey {
            try codedOutputStream.writeString(fieldNumber: 1, value:key)
        }
        if hasTo {
            try codedOutputStream.writeString(fieldNumber: 2, value:to)
        }
        if hasFrom {
            try codedOutputStream.writeString(fieldNumber: 3, value:from)
        }
        if hasAudio {
            try codedOutputStream.writeBool(fieldNumber: 4, value:audio)
        }
        if hasVideo {
            try codedOutputStream.writeBool(fieldNumber: 5, value:video)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasKey {
            serialize_size += key.computeStringSize(fieldNumber: 1)
        }
        if hasTo {
            serialize_size += to.computeStringSize(fieldNumber: 2)
        }
        if hasFrom {
            serialize_size += from.computeStringSize(fieldNumber: 3)
        }
        if hasAudio {
            serialize_size += audio.computeBoolSize(fieldNumber: 4)
        }
        if hasVideo {
            serialize_size += video.computeBoolSize(fieldNumber: 5)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Call.Builder {
        return Call.classBuilder() as! Call.Builder
    }
    public func getBuilder() -> Call.Builder {
        return classBuilder() as! Call.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Call.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Call.Builder()
    }
    public func toBuilder() throws -> Call.Builder {
        return try Call.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Call) throws -> Call.Builder {
        return try Call.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasKey {
            jsonMap["key"] = key
        }
        if hasTo {
            jsonMap["to"] = to
        }
        if hasFrom {
            jsonMap["from"] = from
        }
        if hasAudio {
            jsonMap["audio"] = audio
        }
        if hasVideo {
            jsonMap["video"] = video
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Call {
        return try Call.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Call {
        return try Call.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasKey {
            output += "\(indent) key: \(key) \n"
        }
        if hasTo {
            output += "\(indent) to: \(to) \n"
        }
        if hasFrom {
            output += "\(indent) from: \(from) \n"
        }
        if hasAudio {
            output += "\(indent) audio: \(audio) \n"
        }
        if hasVideo {
            output += "\(indent) video: \(video) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasKey {
                hashCode = (hashCode &* 31) &+ key.hashValue
            }
            if hasTo {
                hashCode = (hashCode &* 31) &+ to.hashValue
            }
            if hasFrom {
                hashCode = (hashCode &* 31) &+ from.hashValue
            }
            if hasAudio {
                hashCode = (hashCode &* 31) &+ audio.hashValue
            }
            if hasVideo {
                hashCode = (hashCode &* 31) &+ video.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Call"
    }
    override public func className() -> String {
        return "Call"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Call = Call()
        public func getMessage() -> Call {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var key:String {
            get {
                return builderResult.key
            }
            set (value) {
                builderResult.hasKey = true
                builderResult.key = value
            }
        }
        public var hasKey:Bool {
            get {
                return builderResult.hasKey
            }
        }
        @discardableResult
        public func setKey(_ value:String) -> Call.Builder {
            self.key = value
            return self
        }
        @discardableResult
        public func clearKey() -> Call.Builder{
            builderResult.hasKey = false
            builderResult.key = nil
            return self
        }
        public var to:String {
            get {
                return builderResult.to
            }
            set (value) {
                builderResult.hasTo = true
                builderResult.to = value
            }
        }
        public var hasTo:Bool {
            get {
                return builderResult.hasTo
            }
        }
        @discardableResult
        public func setTo(_ value:String) -> Call.Builder {
            self.to = value
            return self
        }
        @discardableResult
        public func clearTo() -> Call.Builder{
            builderResult.hasTo = false
            builderResult.to = nil
            return self
        }
        public var from:String {
            get {
                return builderResult.from
            }
            set (value) {
                builderResult.hasFrom = true
                builderResult.from = value
            }
        }
        public var hasFrom:Bool {
            get {
                return builderResult.hasFrom
            }
        }
        @discardableResult
        public func setFrom(_ value:String) -> Call.Builder {
            self.from = value
            return self
        }
        @discardableResult
        public func clearFrom() -> Call.Builder{
            builderResult.hasFrom = false
            builderResult.from = nil
            return self
        }
        public var audio:Bool {
            get {
                return builderResult.audio
            }
            set (value) {
                builderResult.hasAudio = true
                builderResult.audio = value
            }
        }
        public var hasAudio:Bool {
            get {
                return builderResult.hasAudio
            }
        }
        @discardableResult
        public func setAudio(_ value:Bool) -> Call.Builder {
            self.audio = value
            return self
        }
        @discardableResult
        public func clearAudio() -> Call.Builder{
            builderResult.hasAudio = false
            builderResult.audio = nil
            return self
        }
        public var video:Bool {
            get {
                return builderResult.video
            }
            set (value) {
                builderResult.hasVideo = true
                builderResult.video = value
            }
        }
        public var hasVideo:Bool {
            get {
                return builderResult.hasVideo
            }
        }
        @discardableResult
        public func setVideo(_ value:Bool) -> Call.Builder {
            self.video = value
            return self
        }
        @discardableResult
        public func clearVideo() -> Call.Builder{
            builderResult.hasVideo = false
            builderResult.video = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Call.Builder {
            builderResult = Call()
            return self
        }
        override public func clone() throws -> Call.Builder {
            return try Call.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Call {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Call {
            let returnMe:Call = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Call) throws -> Call.Builder {
            if other == Call() {
                return self
            }
            if other.hasKey {
                key = other.key
            }
            if other.hasTo {
                to = other.to
            }
            if other.hasFrom {
                from = other.from
            }
            if other.hasAudio {
                audio = other.audio
            }
            if other.hasVideo {
                video = other.video
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Call.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Call.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    key = try codedInputStream.readString()

                case 18:
                    to = try codedInputStream.readString()

                case 26:
                    from = try codedInputStream.readString()

                case 32:
                    audio = try codedInputStream.readBool()

                case 40:
                    video = try codedInputStream.readBool()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Call.Builder {
            let resultDecodedBuilder = Call.Builder()
            if let jsonValueKey = jsonMap["key"] as? String {
                resultDecodedBuilder.key = jsonValueKey
            }
            if let jsonValueTo = jsonMap["to"] as? String {
                resultDecodedBuilder.to = jsonValueTo
            }
            if let jsonValueFrom = jsonMap["from"] as? String {
                resultDecodedBuilder.from = jsonValueFrom
            }
            if let jsonValueAudio = jsonMap["audio"] as? Bool {
                resultDecodedBuilder.audio = jsonValueAudio
            }
            if let jsonValueVideo = jsonMap["video"] as? Bool {
                resultDecodedBuilder.video = jsonValueVideo
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Call.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Call.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Time : GeneratedMessage {

    public static func == (lhs: Time, rhs: Time) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
        fieldCheck = fieldCheck && (lhs.hasScale == rhs.hasScale) && (!lhs.hasScale || lhs.scale == rhs.scale)
        fieldCheck = fieldCheck && (lhs.hasFlags == rhs.hasFlags) && (!lhs.hasFlags || lhs.flags == rhs.flags)
        fieldCheck = fieldCheck && (lhs.hasEpoch == rhs.hasEpoch) && (!lhs.hasEpoch || lhs.epoch == rhs.epoch)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var value:Int64! = nil
    public fileprivate(set) var hasValue:Bool = false

    public fileprivate(set) var scale:Int32! = nil
    public fileprivate(set) var hasScale:Bool = false

    public fileprivate(set) var flags:UInt32! = nil
    public fileprivate(set) var hasFlags:Bool = false

    public fileprivate(set) var epoch:Int64! = nil
    public fileprivate(set) var hasEpoch:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasValue {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:value)
        }
        if hasScale {
            try codedOutputStream.writeInt32(fieldNumber: 2, value:scale)
        }
        if hasFlags {
            try codedOutputStream.writeUInt32(fieldNumber: 3, value:flags)
        }
        if hasEpoch {
            try codedOutputStream.writeInt64(fieldNumber: 4, value:epoch)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasValue {
            serialize_size += value.computeInt64Size(fieldNumber: 1)
        }
        if hasScale {
            serialize_size += scale.computeInt32Size(fieldNumber: 2)
        }
        if hasFlags {
            serialize_size += flags.computeUInt32Size(fieldNumber: 3)
        }
        if hasEpoch {
            serialize_size += epoch.computeInt64Size(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Time.Builder {
        return Time.classBuilder() as! Time.Builder
    }
    public func getBuilder() -> Time.Builder {
        return classBuilder() as! Time.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Time.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Time.Builder()
    }
    public func toBuilder() throws -> Time.Builder {
        return try Time.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Time) throws -> Time.Builder {
        return try Time.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasValue {
            jsonMap["value"] = "\(value)"
        }
        if hasScale {
            jsonMap["scale"] = Int(scale)
        }
        if hasFlags {
            jsonMap["flags"] = UInt(flags)
        }
        if hasEpoch {
            jsonMap["epoch"] = "\(epoch)"
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Time {
        return try Time.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Time {
        return try Time.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasValue {
            output += "\(indent) value: \(value) \n"
        }
        if hasScale {
            output += "\(indent) scale: \(scale) \n"
        }
        if hasFlags {
            output += "\(indent) flags: \(flags) \n"
        }
        if hasEpoch {
            output += "\(indent) epoch: \(epoch) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasValue {
                hashCode = (hashCode &* 31) &+ value.hashValue
            }
            if hasScale {
                hashCode = (hashCode &* 31) &+ scale.hashValue
            }
            if hasFlags {
                hashCode = (hashCode &* 31) &+ flags.hashValue
            }
            if hasEpoch {
                hashCode = (hashCode &* 31) &+ epoch.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Time"
    }
    override public func className() -> String {
        return "Time"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Time = Time()
        public func getMessage() -> Time {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var value:Int64 {
            get {
                return builderResult.value
            }
            set (value) {
                builderResult.hasValue = true
                builderResult.value = value
            }
        }
        public var hasValue:Bool {
            get {
                return builderResult.hasValue
            }
        }
        @discardableResult
        public func setValue(_ value:Int64) -> Time.Builder {
            self.value = value
            return self
        }
        @discardableResult
        public func clearValue() -> Time.Builder{
            builderResult.hasValue = false
            builderResult.value = nil
            return self
        }
        public var scale:Int32 {
            get {
                return builderResult.scale
            }
            set (value) {
                builderResult.hasScale = true
                builderResult.scale = value
            }
        }
        public var hasScale:Bool {
            get {
                return builderResult.hasScale
            }
        }
        @discardableResult
        public func setScale(_ value:Int32) -> Time.Builder {
            self.scale = value
            return self
        }
        @discardableResult
        public func clearScale() -> Time.Builder{
            builderResult.hasScale = false
            builderResult.scale = nil
            return self
        }
        public var flags:UInt32 {
            get {
                return builderResult.flags
            }
            set (value) {
                builderResult.hasFlags = true
                builderResult.flags = value
            }
        }
        public var hasFlags:Bool {
            get {
                return builderResult.hasFlags
            }
        }
        @discardableResult
        public func setFlags(_ value:UInt32) -> Time.Builder {
            self.flags = value
            return self
        }
        @discardableResult
        public func clearFlags() -> Time.Builder{
            builderResult.hasFlags = false
            builderResult.flags = nil
            return self
        }
        public var epoch:Int64 {
            get {
                return builderResult.epoch
            }
            set (value) {
                builderResult.hasEpoch = true
                builderResult.epoch = value
            }
        }
        public var hasEpoch:Bool {
            get {
                return builderResult.hasEpoch
            }
        }
        @discardableResult
        public func setEpoch(_ value:Int64) -> Time.Builder {
            self.epoch = value
            return self
        }
        @discardableResult
        public func clearEpoch() -> Time.Builder{
            builderResult.hasEpoch = false
            builderResult.epoch = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Time.Builder {
            builderResult = Time()
            return self
        }
        override public func clone() throws -> Time.Builder {
            return try Time.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Time {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Time {
            let returnMe:Time = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Time) throws -> Time.Builder {
            if other == Time() {
                return self
            }
            if other.hasValue {
                value = other.value
            }
            if other.hasScale {
                scale = other.scale
            }
            if other.hasFlags {
                flags = other.flags
            }
            if other.hasEpoch {
                epoch = other.epoch
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Time.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Time.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    value = try codedInputStream.readInt64()

                case 16:
                    scale = try codedInputStream.readInt32()

                case 24:
                    flags = try codedInputStream.readUInt32()

                case 32:
                    epoch = try codedInputStream.readInt64()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Time.Builder {
            let resultDecodedBuilder = Time.Builder()
            if let jsonValueValue = jsonMap["value"] as? String {
                resultDecodedBuilder.value = Int64(jsonValueValue)!
            } else if let jsonValueValue = jsonMap["value"] as? Int {
                resultDecodedBuilder.value = Int64(jsonValueValue)
            }
            if let jsonValueScale = jsonMap["scale"] as? Int {
                resultDecodedBuilder.scale = Int32(jsonValueScale)
            } else if let jsonValueScale = jsonMap["scale"] as? String {
                resultDecodedBuilder.scale = Int32(jsonValueScale)!
            }
            if let jsonValueFlags = jsonMap["flags"] as? UInt {
                resultDecodedBuilder.flags = UInt32(jsonValueFlags)
            } else if let jsonValueFlags = jsonMap["flags"] as? String {
                resultDecodedBuilder.flags = UInt32(jsonValueFlags)!
            }
            if let jsonValueEpoch = jsonMap["epoch"] as? String {
                resultDecodedBuilder.epoch = Int64(jsonValueEpoch)!
            } else if let jsonValueEpoch = jsonMap["epoch"] as? Int {
                resultDecodedBuilder.epoch = Int64(jsonValueEpoch)
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Time.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Time.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Timestamp : GeneratedMessage {

    public static func == (lhs: Timestamp, rhs: Timestamp) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasDuration == rhs.hasDuration) && (!lhs.hasDuration || lhs.duration == rhs.duration)
        fieldCheck = fieldCheck && (lhs.hasPresentation == rhs.hasPresentation) && (!lhs.hasPresentation || lhs.presentation == rhs.presentation)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var duration:Time!
    public fileprivate(set) var hasDuration:Bool = false
    public fileprivate(set) var presentation:Time!
    public fileprivate(set) var hasPresentation:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasDuration {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:duration)
        }
        if hasPresentation {
            try codedOutputStream.writeMessage(fieldNumber: 2, value:presentation)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasDuration {
            if let varSizeduration = duration?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizeduration
            }
        }
        if hasPresentation {
            if let varSizepresentation = presentation?.computeMessageSize(fieldNumber: 2) {
                serialize_size += varSizepresentation
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Timestamp.Builder {
        return Timestamp.classBuilder() as! Timestamp.Builder
    }
    public func getBuilder() -> Timestamp.Builder {
        return classBuilder() as! Timestamp.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Timestamp.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Timestamp.Builder()
    }
    public func toBuilder() throws -> Timestamp.Builder {
        return try Timestamp.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Timestamp) throws -> Timestamp.Builder {
        return try Timestamp.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasDuration {
            jsonMap["duration"] = try duration.encode()
        }
        if hasPresentation {
            jsonMap["presentation"] = try presentation.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Timestamp {
        return try Timestamp.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Timestamp {
        return try Timestamp.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasDuration {
            output += "\(indent) duration {\n"
            if let outDescDuration = duration {
                output += try outDescDuration.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasPresentation {
            output += "\(indent) presentation {\n"
            if let outDescPresentation = presentation {
                output += try outDescPresentation.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDuration {
                if let hashValueduration = duration?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueduration
                }
            }
            if hasPresentation {
                if let hashValuepresentation = presentation?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuepresentation
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Timestamp"
    }
    override public func className() -> String {
        return "Timestamp"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Timestamp = Timestamp()
        public func getMessage() -> Timestamp {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var duration:Time! {
            get {
                if durationBuilder_ != nil {
                    builderResult.duration = durationBuilder_.getMessage()
                }
                return builderResult.duration
            }
            set (value) {
                builderResult.hasDuration = true
                builderResult.duration = value
            }
        }
        public var hasDuration:Bool {
            get {
                return builderResult.hasDuration
            }
        }
        fileprivate var durationBuilder_:Time.Builder! {
            didSet {
                builderResult.hasDuration = true
            }
        }
        public func getDurationBuilder() -> Time.Builder {
            if durationBuilder_ == nil {
                durationBuilder_ = Time.Builder()
                builderResult.duration = durationBuilder_.getMessage()
                if duration != nil {
                    try! durationBuilder_.mergeFrom(other: duration)
                }
            }
            return durationBuilder_
        }
        @discardableResult
        public func setDuration(_ value:Time!) -> Timestamp.Builder {
            self.duration = value
            return self
        }
        @discardableResult
        public func mergeDuration(value:Time) throws -> Timestamp.Builder {
            if builderResult.hasDuration {
                builderResult.duration = try Time.builderWithPrototype(prototype:builderResult.duration).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.duration = value
            }
            builderResult.hasDuration = true
            return self
        }
        @discardableResult
        public func clearDuration() -> Timestamp.Builder {
            durationBuilder_ = nil
            builderResult.hasDuration = false
            builderResult.duration = nil
            return self
        }
        public var presentation:Time! {
            get {
                if presentationBuilder_ != nil {
                    builderResult.presentation = presentationBuilder_.getMessage()
                }
                return builderResult.presentation
            }
            set (value) {
                builderResult.hasPresentation = true
                builderResult.presentation = value
            }
        }
        public var hasPresentation:Bool {
            get {
                return builderResult.hasPresentation
            }
        }
        fileprivate var presentationBuilder_:Time.Builder! {
            didSet {
                builderResult.hasPresentation = true
            }
        }
        public func getPresentationBuilder() -> Time.Builder {
            if presentationBuilder_ == nil {
                presentationBuilder_ = Time.Builder()
                builderResult.presentation = presentationBuilder_.getMessage()
                if presentation != nil {
                    try! presentationBuilder_.mergeFrom(other: presentation)
                }
            }
            return presentationBuilder_
        }
        @discardableResult
        public func setPresentation(_ value:Time!) -> Timestamp.Builder {
            self.presentation = value
            return self
        }
        @discardableResult
        public func mergePresentation(value:Time) throws -> Timestamp.Builder {
            if builderResult.hasPresentation {
                builderResult.presentation = try Time.builderWithPrototype(prototype:builderResult.presentation).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.presentation = value
            }
            builderResult.hasPresentation = true
            return self
        }
        @discardableResult
        public func clearPresentation() -> Timestamp.Builder {
            presentationBuilder_ = nil
            builderResult.hasPresentation = false
            builderResult.presentation = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Timestamp.Builder {
            builderResult = Timestamp()
            return self
        }
        override public func clone() throws -> Timestamp.Builder {
            return try Timestamp.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Timestamp {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Timestamp {
            let returnMe:Timestamp = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Timestamp) throws -> Timestamp.Builder {
            if other == Timestamp() {
                return self
            }
            if (other.hasDuration) {
                try mergeDuration(value: other.duration)
            }
            if (other.hasPresentation) {
                try mergePresentation(value: other.presentation)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Timestamp.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Timestamp.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:Time.Builder = Time.Builder()
                    if hasDuration {
                        try subBuilder.mergeFrom(other: duration)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    duration = subBuilder.buildPartial()

                case 18:
                    let subBuilder:Time.Builder = Time.Builder()
                    if hasPresentation {
                        try subBuilder.mergeFrom(other: presentation)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    presentation = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Timestamp.Builder {
            let resultDecodedBuilder = Timestamp.Builder()
            if let jsonValueDuration = jsonMap["duration"] as? Dictionary<String,Any> {
                resultDecodedBuilder.duration = try Time.Builder.decodeToBuilder(jsonMap:jsonValueDuration).build()

            }
            if let jsonValuePresentation = jsonMap["presentation"] as? Dictionary<String,Any> {
                resultDecodedBuilder.presentation = try Time.Builder.decodeToBuilder(jsonMap:jsonValuePresentation).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Timestamp.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Timestamp.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Image : GeneratedMessage {

    public static func == (lhs: Image, rhs: Image) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasWidth == rhs.hasWidth) && (!lhs.hasWidth || lhs.width == rhs.width)
        fieldCheck = fieldCheck && (lhs.hasHeight == rhs.hasHeight) && (!lhs.hasHeight || lhs.height == rhs.height)
        fieldCheck = fieldCheck && (lhs.hasFormat == rhs.hasFormat) && (!lhs.hasFormat || lhs.format == rhs.format)
        fieldCheck = fieldCheck && (lhs.hasAttachments == rhs.hasAttachments) && (!lhs.hasAttachments || lhs.attachments == rhs.attachments)
        fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



    //Nested type declaration start

    final public class AttachmentsEntry : GeneratedMessage {

        public static func == (lhs: Image.AttachmentsEntry, rhs: Image.AttachmentsEntry) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
            fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var key:String! = nil
        public fileprivate(set) var hasKey:Bool = false

        public fileprivate(set) var value:String! = nil
        public fileprivate(set) var hasValue:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasKey {
                try codedOutputStream.writeString(fieldNumber: 1, value:key)
            }
            if hasValue {
                try codedOutputStream.writeString(fieldNumber: 2, value:value)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasKey {
                serialize_size += key.computeStringSize(fieldNumber: 1)
            }
            if hasValue {
                serialize_size += value.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> Image.AttachmentsEntry.Builder {
            return Image.AttachmentsEntry.classBuilder() as! Image.AttachmentsEntry.Builder
        }
        public func getBuilder() -> Image.AttachmentsEntry.Builder {
            return classBuilder() as! Image.AttachmentsEntry.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Image.AttachmentsEntry.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return Image.AttachmentsEntry.Builder()
        }
        public func toBuilder() throws -> Image.AttachmentsEntry.Builder {
            return try Image.AttachmentsEntry.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:Image.AttachmentsEntry) throws -> Image.AttachmentsEntry.Builder {
            return try Image.AttachmentsEntry.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasKey {
                jsonMap["key"] = key
            }
            if hasValue {
                jsonMap["value"] = value
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Image.AttachmentsEntry {
            return try Image.AttachmentsEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> Image.AttachmentsEntry {
            return try Image.AttachmentsEntry.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasKey {
                output += "\(indent) key: \(key) \n"
            }
            if hasValue {
                output += "\(indent) value: \(value) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                    hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                    hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "Image.AttachmentsEntry"
        }
        override public func className() -> String {
            return "Image.AttachmentsEntry"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:Image.AttachmentsEntry = Image.AttachmentsEntry()
            public func getMessage() -> Image.AttachmentsEntry {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var key:String {
                get {
                    return builderResult.key
                }
                set (value) {
                    builderResult.hasKey = true
                    builderResult.key = value
                }
            }
            public var hasKey:Bool {
                get {
                    return builderResult.hasKey
                }
            }
            @discardableResult
            public func setKey(_ value:String) -> Image.AttachmentsEntry.Builder {
                self.key = value
                return self
            }
            @discardableResult
            public func clearKey() -> Image.AttachmentsEntry.Builder{
                builderResult.hasKey = false
                builderResult.key = nil
                return self
            }
            public var value:String {
                get {
                    return builderResult.value
                }
                set (value) {
                    builderResult.hasValue = true
                    builderResult.value = value
                }
            }
            public var hasValue:Bool {
                get {
                    return builderResult.hasValue
                }
            }
            @discardableResult
            public func setValue(_ value:String) -> Image.AttachmentsEntry.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> Image.AttachmentsEntry.Builder{
                builderResult.hasValue = false
                builderResult.value = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> Image.AttachmentsEntry.Builder {
                builderResult = Image.AttachmentsEntry()
                return self
            }
            override public func clone() throws -> Image.AttachmentsEntry.Builder {
                return try Image.AttachmentsEntry.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> Image.AttachmentsEntry {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> Image.AttachmentsEntry {
                let returnMe:Image.AttachmentsEntry = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:Image.AttachmentsEntry) throws -> Image.AttachmentsEntry.Builder {
                if other == Image.AttachmentsEntry() {
                    return self
                }
                if other.hasKey {
                    key = other.key
                }
                if other.hasValue {
                    value = other.value
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Image.AttachmentsEntry.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Image.AttachmentsEntry.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        key = try codedInputStream.readString()

                    case 18:
                        value = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Image.AttachmentsEntry.Builder {
                let resultDecodedBuilder = Image.AttachmentsEntry.Builder()
                if let jsonValueKey = jsonMap["key"] as? String {
                    resultDecodedBuilder.key = jsonValueKey
                }
                if let jsonValueValue = jsonMap["value"] as? String {
                    resultDecodedBuilder.value = jsonValueValue
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> Image.AttachmentsEntry.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try Image.AttachmentsEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    //Nested type declaration end

    public fileprivate(set) var width:Int64! = nil
    public fileprivate(set) var hasWidth:Bool = false

    public fileprivate(set) var height:Int64! = nil
    public fileprivate(set) var hasHeight:Bool = false

    public fileprivate(set) var format:UInt32! = nil
    public fileprivate(set) var hasFormat:Bool = false

    public fileprivate(set) var attachments:Dictionary<String,String> = Dictionary<String,String>()

    public fileprivate(set) var hasAttachments:Bool = false
    public fileprivate(set) var data:Data! = nil
    public fileprivate(set) var hasData:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasWidth {
            try codedOutputStream.writeInt64(fieldNumber: 1, value:width)
        }
        if hasHeight {
            try codedOutputStream.writeInt64(fieldNumber: 2, value:height)
        }
        if hasFormat {
            try codedOutputStream.writeUInt32(fieldNumber: 3, value:format)
        }
        if hasAttachments {
            for (keyAttachments, valueAttachments) in attachments {
                let valueOfAttachments = try! Image.AttachmentsEntry.Builder().setKey(keyAttachments).setValue(valueAttachments).build()
                  try codedOutputStream.writeMessage(fieldNumber: 4, value:valueOfAttachments)
              }
        }
        if hasData {
            try codedOutputStream.writeData(fieldNumber: 5, value:data)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasWidth {
            serialize_size += width.computeInt64Size(fieldNumber: 1)
        }
        if hasHeight {
            serialize_size += height.computeInt64Size(fieldNumber: 2)
        }
        if hasFormat {
            serialize_size += format.computeUInt32Size(fieldNumber: 3)
        }
        if hasAttachments {
              for (keyAttachments, valueAttachments) in attachments {
                  let valueOfAttachments = try! Image.AttachmentsEntry.Builder().setKey(keyAttachments).setValue(valueAttachments).build()
            serialize_size += valueOfAttachments.computeMessageSize(fieldNumber: 4)
            }
        }
        if hasData {
            serialize_size += data.computeDataSize(fieldNumber: 5)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Image.Builder {
        return Image.classBuilder() as! Image.Builder
    }
    public func getBuilder() -> Image.Builder {
        return classBuilder() as! Image.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Image.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Image.Builder()
    }
    public func toBuilder() throws -> Image.Builder {
        return try Image.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Image) throws -> Image.Builder {
        return try Image.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasWidth {
            jsonMap["width"] = "\(width)"
        }
        if hasHeight {
            jsonMap["height"] = "\(height)"
        }
        if hasFormat {
            jsonMap["format"] = UInt(format)
        }
        if hasAttachments {
            var mapAttachments = Dictionary<String, String>()
            for (keyAttachments, valueAttachments) in attachments {
                mapAttachments["\(keyAttachments)"] = valueAttachments
            }
            jsonMap["attachments"] = mapAttachments
        }
        if hasData {
            jsonMap["data"] = data.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Image {
        return try Image.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Image {
        return try Image.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasWidth {
            output += "\(indent) width: \(width) \n"
        }
        if hasHeight {
            output += "\(indent) height: \(height) \n"
        }
        if hasFormat {
            output += "\(indent) format: \(format) \n"
        }
        if hasAttachments {
            output += "\(indent) attachments: \(attachments) \n"
        }
        if hasData {
            output += "\(indent) data: \(data) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasWidth {
                hashCode = (hashCode &* 31) &+ width.hashValue
            }
            if hasHeight {
                hashCode = (hashCode &* 31) &+ height.hashValue
            }
            if hasFormat {
                hashCode = (hashCode &* 31) &+ format.hashValue
            }
            if hasAttachments {
                for (keyAttachments, valueAttachments) in attachments {
                    hashCode = (hashCode &* 31) &+ keyAttachments.hashValue
                    hashCode = (hashCode &* 31) &+ valueAttachments.hashValue
                }
            }
            if hasData {
                hashCode = (hashCode &* 31) &+ data.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Image"
    }
    override public func className() -> String {
        return "Image"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Image = Image()
        public func getMessage() -> Image {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var width:Int64 {
            get {
                return builderResult.width
            }
            set (value) {
                builderResult.hasWidth = true
                builderResult.width = value
            }
        }
        public var hasWidth:Bool {
            get {
                return builderResult.hasWidth
            }
        }
        @discardableResult
        public func setWidth(_ value:Int64) -> Image.Builder {
            self.width = value
            return self
        }
        @discardableResult
        public func clearWidth() -> Image.Builder{
            builderResult.hasWidth = false
            builderResult.width = nil
            return self
        }
        public var height:Int64 {
            get {
                return builderResult.height
            }
            set (value) {
                builderResult.hasHeight = true
                builderResult.height = value
            }
        }
        public var hasHeight:Bool {
            get {
                return builderResult.hasHeight
            }
        }
        @discardableResult
        public func setHeight(_ value:Int64) -> Image.Builder {
            self.height = value
            return self
        }
        @discardableResult
        public func clearHeight() -> Image.Builder{
            builderResult.hasHeight = false
            builderResult.height = nil
            return self
        }
        public var format:UInt32 {
            get {
                return builderResult.format
            }
            set (value) {
                builderResult.hasFormat = true
                builderResult.format = value
            }
        }
        public var hasFormat:Bool {
            get {
                return builderResult.hasFormat
            }
        }
        @discardableResult
        public func setFormat(_ value:UInt32) -> Image.Builder {
            self.format = value
            return self
        }
        @discardableResult
        public func clearFormat() -> Image.Builder{
            builderResult.hasFormat = false
            builderResult.format = nil
            return self
        }
        public var hasAttachments:Bool {
            get {
                return builderResult.hasAttachments
            }
        }
        public var attachments:Dictionary<String,String> {
            get {
                return builderResult.attachments
            }
            set (value) {
                builderResult.hasAttachments = true
                builderResult.attachments = value
            }
        }
        @discardableResult
        public func setAttachments(_ value:Dictionary<String,String>) -> Image.Builder {
            self.attachments = value
            return self
        }
        @discardableResult
        public func clearAttachments() -> Image.Builder{
            builderResult.hasAttachments = false
            builderResult.attachments = Dictionary<String,String>()
            return self
        }
        public var data:Data {
            get {
                return builderResult.data
            }
            set (value) {
                builderResult.hasData = true
                builderResult.data = value
            }
        }
        public var hasData:Bool {
            get {
                return builderResult.hasData
            }
        }
        @discardableResult
        public func setData(_ value:Data) -> Image.Builder {
            self.data = value
            return self
        }
        @discardableResult
        public func clearData() -> Image.Builder{
            builderResult.hasData = false
            builderResult.data = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Image.Builder {
            builderResult = Image()
            return self
        }
        override public func clone() throws -> Image.Builder {
            return try Image.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Image {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Image {
            let returnMe:Image = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Image) throws -> Image.Builder {
            if other == Image() {
                return self
            }
            if other.hasWidth {
                width = other.width
            }
            if other.hasHeight {
                height = other.height
            }
            if other.hasFormat {
                format = other.format
            }
            if other.hasAttachments {
                attachments = other.attachments
            }
            if other.hasData {
                data = other.data
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Image.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Image.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    width = try codedInputStream.readInt64()

                case 16:
                    height = try codedInputStream.readInt64()

                case 24:
                    format = try codedInputStream.readUInt32()

                case 34:
                    let subBuilder = Image.AttachmentsEntry.Builder()
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    let buildOfAttachments = subBuilder.buildPartial()
                    attachments[buildOfAttachments.key] = buildOfAttachments.value

                case 42:
                    data = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Image.Builder {
            let resultDecodedBuilder = Image.Builder()
            if let jsonValueWidth = jsonMap["width"] as? String {
                resultDecodedBuilder.width = Int64(jsonValueWidth)!
            } else if let jsonValueWidth = jsonMap["width"] as? Int {
                resultDecodedBuilder.width = Int64(jsonValueWidth)
            }
            if let jsonValueHeight = jsonMap["height"] as? String {
                resultDecodedBuilder.height = Int64(jsonValueHeight)!
            } else if let jsonValueHeight = jsonMap["height"] as? Int {
                resultDecodedBuilder.height = Int64(jsonValueHeight)
            }
            if let jsonValueFormat = jsonMap["format"] as? UInt {
                resultDecodedBuilder.format = UInt32(jsonValueFormat)
            } else if let jsonValueFormat = jsonMap["format"] as? String {
                resultDecodedBuilder.format = UInt32(jsonValueFormat)!
            }
            if let jsonValueAttachments = jsonMap["attachments"] as? Dictionary<String, String> {
                var mapAttachments = Dictionary<String, String>()
                for (keyAttachments, valueAttachments) in jsonValueAttachments {
                    guard let keyFromAttachments = String(keyAttachments) else {
                        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    mapAttachments[keyFromAttachments] = valueAttachments
                }
                resultDecodedBuilder.attachments = mapAttachments
            }
            if let jsonValueData = jsonMap["data"] as? String {
                resultDecodedBuilder.data = Data(base64Encoded:jsonValueData, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Image.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Image.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class FormatDescription : GeneratedMessage {

    public static func == (lhs: FormatDescription, rhs: FormatDescription) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasMediaType == rhs.hasMediaType) && (!lhs.hasMediaType || lhs.mediaType == rhs.mediaType)
        fieldCheck = fieldCheck && (lhs.hasMediaSubtype == rhs.hasMediaSubtype) && (!lhs.hasMediaSubtype || lhs.mediaSubtype == rhs.mediaSubtype)
        fieldCheck = fieldCheck && (lhs.hasExtensions == rhs.hasExtensions) && (!lhs.hasExtensions || lhs.extensions == rhs.extensions)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



    //Nested type declaration start

    final public class ExtensionsEntry : GeneratedMessage {

        public static func == (lhs: FormatDescription.ExtensionsEntry, rhs: FormatDescription.ExtensionsEntry) -> Bool {
            if lhs === rhs {
                return true
            }
            var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
            fieldCheck = fieldCheck && (lhs.hasKey == rhs.hasKey) && (!lhs.hasKey || lhs.key == rhs.key)
            fieldCheck = fieldCheck && (lhs.hasValue == rhs.hasValue) && (!lhs.hasValue || lhs.value == rhs.value)
            fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
            return fieldCheck
        }

        public fileprivate(set) var key:String! = nil
        public fileprivate(set) var hasKey:Bool = false

        public fileprivate(set) var value:String! = nil
        public fileprivate(set) var hasValue:Bool = false

        required public init() {
            super.init()
        }
        override public func isInitialized() -> Bool {
            return true
        }
        override public func writeTo(codedOutputStream: CodedOutputStream) throws {
            if hasKey {
                try codedOutputStream.writeString(fieldNumber: 1, value:key)
            }
            if hasValue {
                try codedOutputStream.writeString(fieldNumber: 2, value:value)
            }
            try unknownFields.writeTo(codedOutputStream: codedOutputStream)
        }
        override public func serializedSize() -> Int32 {
            var serialize_size:Int32 = memoizedSerializedSize
            if serialize_size != -1 {
             return serialize_size
            }

            serialize_size = 0
            if hasKey {
                serialize_size += key.computeStringSize(fieldNumber: 1)
            }
            if hasValue {
                serialize_size += value.computeStringSize(fieldNumber: 2)
            }
            serialize_size += unknownFields.serializedSize()
            memoizedSerializedSize = serialize_size
            return serialize_size
        }
        public class func getBuilder() -> FormatDescription.ExtensionsEntry.Builder {
            return FormatDescription.ExtensionsEntry.classBuilder() as! FormatDescription.ExtensionsEntry.Builder
        }
        public func getBuilder() -> FormatDescription.ExtensionsEntry.Builder {
            return classBuilder() as! FormatDescription.ExtensionsEntry.Builder
        }
        override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
            return FormatDescription.ExtensionsEntry.Builder()
        }
        override public func classBuilder() -> ProtocolBuffersMessageBuilder {
            return FormatDescription.ExtensionsEntry.Builder()
        }
        public func toBuilder() throws -> FormatDescription.ExtensionsEntry.Builder {
            return try FormatDescription.ExtensionsEntry.builderWithPrototype(prototype:self)
        }
        public class func builderWithPrototype(prototype:FormatDescription.ExtensionsEntry) throws -> FormatDescription.ExtensionsEntry.Builder {
            return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(other:prototype)
        }
        override public func encode() throws -> Dictionary<String,Any> {
            guard isInitialized() else {
                throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
            }

            var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
            if hasKey {
                jsonMap["key"] = key
            }
            if hasValue {
                jsonMap["value"] = value
            }
            return jsonMap
        }
        override class public func decode(jsonMap:Dictionary<String,Any>) throws -> FormatDescription.ExtensionsEntry {
            return try FormatDescription.ExtensionsEntry.Builder.decodeToBuilder(jsonMap:jsonMap).build()
        }
        override class public func fromJSON(data:Data) throws -> FormatDescription.ExtensionsEntry {
            return try FormatDescription.ExtensionsEntry.Builder.fromJSONToBuilder(data:data).build()
        }
        override public func getDescription(indent:String) throws -> String {
            var output = ""
            if hasKey {
                output += "\(indent) key: \(key) \n"
            }
            if hasValue {
                output += "\(indent) value: \(value) \n"
            }
            output += unknownFields.getDescription(indent: indent)
            return output
        }
        override public var hashValue:Int {
            get {
                var hashCode:Int = 7
                if hasKey {
                    hashCode = (hashCode &* 31) &+ key.hashValue
                }
                if hasValue {
                    hashCode = (hashCode &* 31) &+ value.hashValue
                }
                hashCode = (hashCode &* 31) &+  unknownFields.hashValue
                return hashCode
            }
        }


        //Meta information declaration start

        override public class func className() -> String {
            return "FormatDescription.ExtensionsEntry"
        }
        override public func className() -> String {
            return "FormatDescription.ExtensionsEntry"
        }
        //Meta information declaration end

        final public class Builder : GeneratedMessageBuilder {
            fileprivate var builderResult:FormatDescription.ExtensionsEntry = FormatDescription.ExtensionsEntry()
            public func getMessage() -> FormatDescription.ExtensionsEntry {
                return builderResult
            }

            required override public init () {
                super.init()
            }
            public var key:String {
                get {
                    return builderResult.key
                }
                set (value) {
                    builderResult.hasKey = true
                    builderResult.key = value
                }
            }
            public var hasKey:Bool {
                get {
                    return builderResult.hasKey
                }
            }
            @discardableResult
            public func setKey(_ value:String) -> FormatDescription.ExtensionsEntry.Builder {
                self.key = value
                return self
            }
            @discardableResult
            public func clearKey() -> FormatDescription.ExtensionsEntry.Builder{
                builderResult.hasKey = false
                builderResult.key = nil
                return self
            }
            public var value:String {
                get {
                    return builderResult.value
                }
                set (value) {
                    builderResult.hasValue = true
                    builderResult.value = value
                }
            }
            public var hasValue:Bool {
                get {
                    return builderResult.hasValue
                }
            }
            @discardableResult
            public func setValue(_ value:String) -> FormatDescription.ExtensionsEntry.Builder {
                self.value = value
                return self
            }
            @discardableResult
            public func clearValue() -> FormatDescription.ExtensionsEntry.Builder{
                builderResult.hasValue = false
                builderResult.value = nil
                return self
            }
            override public var internalGetResult:GeneratedMessage {
                get {
                    return builderResult
                }
            }
            @discardableResult
            override public func clear() -> FormatDescription.ExtensionsEntry.Builder {
                builderResult = FormatDescription.ExtensionsEntry()
                return self
            }
            override public func clone() throws -> FormatDescription.ExtensionsEntry.Builder {
                return try FormatDescription.ExtensionsEntry.builderWithPrototype(prototype:builderResult)
            }
            override public func build() throws -> FormatDescription.ExtensionsEntry {
                try checkInitialized()
                return buildPartial()
            }
            public func buildPartial() -> FormatDescription.ExtensionsEntry {
                let returnMe:FormatDescription.ExtensionsEntry = builderResult
                return returnMe
            }
            @discardableResult
            public func mergeFrom(other:FormatDescription.ExtensionsEntry) throws -> FormatDescription.ExtensionsEntry.Builder {
                if other == FormatDescription.ExtensionsEntry() {
                    return self
                }
                if other.hasKey {
                    key = other.key
                }
                if other.hasValue {
                    value = other.value
                }
                try merge(unknownField: other.unknownFields)
                return self
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream) throws -> FormatDescription.ExtensionsEntry.Builder {
                return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
            }
            @discardableResult
            override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> FormatDescription.ExtensionsEntry.Builder {
                let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
                while (true) {
                    let protobufTag = try codedInputStream.readTag()
                    switch protobufTag {
                    case 0: 
                        self.unknownFields = try unknownFieldsBuilder.build()
                        return self

                    case 10:
                        key = try codedInputStream.readString()

                    case 18:
                        value = try codedInputStream.readString()

                    default:
                        if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                            unknownFields = try unknownFieldsBuilder.build()
                            return self
                        }
                    }
                }
            }
            class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> FormatDescription.ExtensionsEntry.Builder {
                let resultDecodedBuilder = FormatDescription.ExtensionsEntry.Builder()
                if let jsonValueKey = jsonMap["key"] as? String {
                    resultDecodedBuilder.key = jsonValueKey
                }
                if let jsonValueValue = jsonMap["value"] as? String {
                    resultDecodedBuilder.value = jsonValueValue
                }
                return resultDecodedBuilder
            }
            override class public func fromJSONToBuilder(data:Data) throws -> FormatDescription.ExtensionsEntry.Builder {
                let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
                guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
                  throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                }
                return try FormatDescription.ExtensionsEntry.Builder.decodeToBuilder(jsonMap:jsDataCast)
            }
        }

    }

    //Nested type declaration end

    public fileprivate(set) var mediaType:UInt32! = nil
    public fileprivate(set) var hasMediaType:Bool = false

    public fileprivate(set) var mediaSubtype:UInt32! = nil
    public fileprivate(set) var hasMediaSubtype:Bool = false

    public fileprivate(set) var extensions:Dictionary<String,String> = Dictionary<String,String>()

    public fileprivate(set) var hasExtensions:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasMediaType {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:mediaType)
        }
        if hasMediaSubtype {
            try codedOutputStream.writeUInt32(fieldNumber: 2, value:mediaSubtype)
        }
        if hasExtensions {
            for (keyExtensions, valueExtensions) in extensions {
                let valueOfExtensions = try! FormatDescription.ExtensionsEntry.Builder().setKey(keyExtensions).setValue(valueExtensions).build()
                  try codedOutputStream.writeMessage(fieldNumber: 3, value:valueOfExtensions)
              }
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasMediaType {
            serialize_size += mediaType.computeUInt32Size(fieldNumber: 1)
        }
        if hasMediaSubtype {
            serialize_size += mediaSubtype.computeUInt32Size(fieldNumber: 2)
        }
        if hasExtensions {
              for (keyExtensions, valueExtensions) in extensions {
                  let valueOfExtensions = try! FormatDescription.ExtensionsEntry.Builder().setKey(keyExtensions).setValue(valueExtensions).build()
            serialize_size += valueOfExtensions.computeMessageSize(fieldNumber: 3)
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> FormatDescription.Builder {
        return FormatDescription.classBuilder() as! FormatDescription.Builder
    }
    public func getBuilder() -> FormatDescription.Builder {
        return classBuilder() as! FormatDescription.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return FormatDescription.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return FormatDescription.Builder()
    }
    public func toBuilder() throws -> FormatDescription.Builder {
        return try FormatDescription.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:FormatDescription) throws -> FormatDescription.Builder {
        return try FormatDescription.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasMediaType {
            jsonMap["mediaType"] = UInt(mediaType)
        }
        if hasMediaSubtype {
            jsonMap["mediaSubtype"] = UInt(mediaSubtype)
        }
        if hasExtensions {
            var mapExtensions = Dictionary<String, String>()
            for (keyExtensions, valueExtensions) in extensions {
                mapExtensions["\(keyExtensions)"] = valueExtensions
            }
            jsonMap["extensions"] = mapExtensions
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> FormatDescription {
        return try FormatDescription.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> FormatDescription {
        return try FormatDescription.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasMediaType {
            output += "\(indent) mediaType: \(mediaType) \n"
        }
        if hasMediaSubtype {
            output += "\(indent) mediaSubtype: \(mediaSubtype) \n"
        }
        if hasExtensions {
            output += "\(indent) extensions: \(extensions) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasMediaType {
                hashCode = (hashCode &* 31) &+ mediaType.hashValue
            }
            if hasMediaSubtype {
                hashCode = (hashCode &* 31) &+ mediaSubtype.hashValue
            }
            if hasExtensions {
                for (keyExtensions, valueExtensions) in extensions {
                    hashCode = (hashCode &* 31) &+ keyExtensions.hashValue
                    hashCode = (hashCode &* 31) &+ valueExtensions.hashValue
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "FormatDescription"
    }
    override public func className() -> String {
        return "FormatDescription"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:FormatDescription = FormatDescription()
        public func getMessage() -> FormatDescription {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var mediaType:UInt32 {
            get {
                return builderResult.mediaType
            }
            set (value) {
                builderResult.hasMediaType = true
                builderResult.mediaType = value
            }
        }
        public var hasMediaType:Bool {
            get {
                return builderResult.hasMediaType
            }
        }
        @discardableResult
        public func setMediaType(_ value:UInt32) -> FormatDescription.Builder {
            self.mediaType = value
            return self
        }
        @discardableResult
        public func clearMediaType() -> FormatDescription.Builder{
            builderResult.hasMediaType = false
            builderResult.mediaType = nil
            return self
        }
        public var mediaSubtype:UInt32 {
            get {
                return builderResult.mediaSubtype
            }
            set (value) {
                builderResult.hasMediaSubtype = true
                builderResult.mediaSubtype = value
            }
        }
        public var hasMediaSubtype:Bool {
            get {
                return builderResult.hasMediaSubtype
            }
        }
        @discardableResult
        public func setMediaSubtype(_ value:UInt32) -> FormatDescription.Builder {
            self.mediaSubtype = value
            return self
        }
        @discardableResult
        public func clearMediaSubtype() -> FormatDescription.Builder{
            builderResult.hasMediaSubtype = false
            builderResult.mediaSubtype = nil
            return self
        }
        public var hasExtensions:Bool {
            get {
                return builderResult.hasExtensions
            }
        }
        public var extensions:Dictionary<String,String> {
            get {
                return builderResult.extensions
            }
            set (value) {
                builderResult.hasExtensions = true
                builderResult.extensions = value
            }
        }
        @discardableResult
        public func setExtensions(_ value:Dictionary<String,String>) -> FormatDescription.Builder {
            self.extensions = value
            return self
        }
        @discardableResult
        public func clearExtensions() -> FormatDescription.Builder{
            builderResult.hasExtensions = false
            builderResult.extensions = Dictionary<String,String>()
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> FormatDescription.Builder {
            builderResult = FormatDescription()
            return self
        }
        override public func clone() throws -> FormatDescription.Builder {
            return try FormatDescription.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> FormatDescription {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> FormatDescription {
            let returnMe:FormatDescription = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:FormatDescription) throws -> FormatDescription.Builder {
            if other == FormatDescription() {
                return self
            }
            if other.hasMediaType {
                mediaType = other.mediaType
            }
            if other.hasMediaSubtype {
                mediaSubtype = other.mediaSubtype
            }
            if other.hasExtensions {
                extensions = other.extensions
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> FormatDescription.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> FormatDescription.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    mediaType = try codedInputStream.readUInt32()

                case 16:
                    mediaSubtype = try codedInputStream.readUInt32()

                case 26:
                    let subBuilder = FormatDescription.ExtensionsEntry.Builder()
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    let buildOfExtensions = subBuilder.buildPartial()
                    extensions[buildOfExtensions.key] = buildOfExtensions.value

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> FormatDescription.Builder {
            let resultDecodedBuilder = FormatDescription.Builder()
            if let jsonValueMediaType = jsonMap["mediaType"] as? UInt {
                resultDecodedBuilder.mediaType = UInt32(jsonValueMediaType)
            } else if let jsonValueMediaType = jsonMap["mediaType"] as? String {
                resultDecodedBuilder.mediaType = UInt32(jsonValueMediaType)!
            }
            if let jsonValueMediaSubtype = jsonMap["mediaSubtype"] as? UInt {
                resultDecodedBuilder.mediaSubtype = UInt32(jsonValueMediaSubtype)
            } else if let jsonValueMediaSubtype = jsonMap["mediaSubtype"] as? String {
                resultDecodedBuilder.mediaSubtype = UInt32(jsonValueMediaSubtype)!
            }
            if let jsonValueExtensions = jsonMap["extensions"] as? Dictionary<String, String> {
                var mapExtensions = Dictionary<String, String>()
                for (keyExtensions, valueExtensions) in jsonValueExtensions {
                    guard let keyFromExtensions = String(keyExtensions) else {
                        throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
                    }
                    mapExtensions[keyFromExtensions] = valueExtensions
                }
                resultDecodedBuilder.extensions = mapExtensions
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> FormatDescription.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try FormatDescription.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class VideoSample : GeneratedMessage {

    public static func == (lhs: VideoSample, rhs: VideoSample) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasImage == rhs.hasImage) && (!lhs.hasImage || lhs.image == rhs.image)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var image:Image!
    public fileprivate(set) var hasImage:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasImage {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:image)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasImage {
            if let varSizeimage = image?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizeimage
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> VideoSample.Builder {
        return VideoSample.classBuilder() as! VideoSample.Builder
    }
    public func getBuilder() -> VideoSample.Builder {
        return classBuilder() as! VideoSample.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return VideoSample.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return VideoSample.Builder()
    }
    public func toBuilder() throws -> VideoSample.Builder {
        return try VideoSample.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:VideoSample) throws -> VideoSample.Builder {
        return try VideoSample.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasImage {
            jsonMap["image"] = try image.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> VideoSample {
        return try VideoSample.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> VideoSample {
        return try VideoSample.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasImage {
            output += "\(indent) image {\n"
            if let outDescImage = image {
                output += try outDescImage.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasImage {
                if let hashValueimage = image?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueimage
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "VideoSample"
    }
    override public func className() -> String {
        return "VideoSample"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:VideoSample = VideoSample()
        public func getMessage() -> VideoSample {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var image:Image! {
            get {
                if imageBuilder_ != nil {
                    builderResult.image = imageBuilder_.getMessage()
                }
                return builderResult.image
            }
            set (value) {
                builderResult.hasImage = true
                builderResult.image = value
            }
        }
        public var hasImage:Bool {
            get {
                return builderResult.hasImage
            }
        }
        fileprivate var imageBuilder_:Image.Builder! {
            didSet {
                builderResult.hasImage = true
            }
        }
        public func getImageBuilder() -> Image.Builder {
            if imageBuilder_ == nil {
                imageBuilder_ = Image.Builder()
                builderResult.image = imageBuilder_.getMessage()
                if image != nil {
                    try! imageBuilder_.mergeFrom(other: image)
                }
            }
            return imageBuilder_
        }
        @discardableResult
        public func setImage(_ value:Image!) -> VideoSample.Builder {
            self.image = value
            return self
        }
        @discardableResult
        public func mergeImage(value:Image) throws -> VideoSample.Builder {
            if builderResult.hasImage {
                builderResult.image = try Image.builderWithPrototype(prototype:builderResult.image).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.image = value
            }
            builderResult.hasImage = true
            return self
        }
        @discardableResult
        public func clearImage() -> VideoSample.Builder {
            imageBuilder_ = nil
            builderResult.hasImage = false
            builderResult.image = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> VideoSample.Builder {
            builderResult = VideoSample()
            return self
        }
        override public func clone() throws -> VideoSample.Builder {
            return try VideoSample.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> VideoSample {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> VideoSample {
            let returnMe:VideoSample = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:VideoSample) throws -> VideoSample.Builder {
            if other == VideoSample() {
                return self
            }
            if (other.hasImage) {
                try mergeImage(value: other.image)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> VideoSample.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VideoSample.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:Image.Builder = Image.Builder()
                    if hasImage {
                        try subBuilder.mergeFrom(other: image)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    image = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> VideoSample.Builder {
            let resultDecodedBuilder = VideoSample.Builder()
            if let jsonValueImage = jsonMap["image"] as? Dictionary<String,Any> {
                resultDecodedBuilder.image = try Image.Builder.decodeToBuilder(jsonMap:jsonValueImage).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> VideoSample.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try VideoSample.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class AudioSample : GeneratedMessage {

    public static func == (lhs: AudioSample, rhs: AudioSample) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasImage == rhs.hasImage) && (!lhs.hasImage || lhs.image == rhs.image)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var image:Image!
    public fileprivate(set) var hasImage:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasImage {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:image)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasImage {
            if let varSizeimage = image?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizeimage
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> AudioSample.Builder {
        return AudioSample.classBuilder() as! AudioSample.Builder
    }
    public func getBuilder() -> AudioSample.Builder {
        return classBuilder() as! AudioSample.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AudioSample.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return AudioSample.Builder()
    }
    public func toBuilder() throws -> AudioSample.Builder {
        return try AudioSample.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:AudioSample) throws -> AudioSample.Builder {
        return try AudioSample.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasImage {
            jsonMap["image"] = try image.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> AudioSample {
        return try AudioSample.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> AudioSample {
        return try AudioSample.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasImage {
            output += "\(indent) image {\n"
            if let outDescImage = image {
                output += try outDescImage.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasImage {
                if let hashValueimage = image?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueimage
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "AudioSample"
    }
    override public func className() -> String {
        return "AudioSample"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:AudioSample = AudioSample()
        public func getMessage() -> AudioSample {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var image:Image! {
            get {
                if imageBuilder_ != nil {
                    builderResult.image = imageBuilder_.getMessage()
                }
                return builderResult.image
            }
            set (value) {
                builderResult.hasImage = true
                builderResult.image = value
            }
        }
        public var hasImage:Bool {
            get {
                return builderResult.hasImage
            }
        }
        fileprivate var imageBuilder_:Image.Builder! {
            didSet {
                builderResult.hasImage = true
            }
        }
        public func getImageBuilder() -> Image.Builder {
            if imageBuilder_ == nil {
                imageBuilder_ = Image.Builder()
                builderResult.image = imageBuilder_.getMessage()
                if image != nil {
                    try! imageBuilder_.mergeFrom(other: image)
                }
            }
            return imageBuilder_
        }
        @discardableResult
        public func setImage(_ value:Image!) -> AudioSample.Builder {
            self.image = value
            return self
        }
        @discardableResult
        public func mergeImage(value:Image) throws -> AudioSample.Builder {
            if builderResult.hasImage {
                builderResult.image = try Image.builderWithPrototype(prototype:builderResult.image).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.image = value
            }
            builderResult.hasImage = true
            return self
        }
        @discardableResult
        public func clearImage() -> AudioSample.Builder {
            imageBuilder_ = nil
            builderResult.hasImage = false
            builderResult.image = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> AudioSample.Builder {
            builderResult = AudioSample()
            return self
        }
        override public func clone() throws -> AudioSample.Builder {
            return try AudioSample.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> AudioSample {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> AudioSample {
            let returnMe:AudioSample = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:AudioSample) throws -> AudioSample.Builder {
            if other == AudioSample() {
                return self
            }
            if (other.hasImage) {
                try mergeImage(value: other.image)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> AudioSample.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AudioSample.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:Image.Builder = Image.Builder()
                    if hasImage {
                        try subBuilder.mergeFrom(other: image)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    image = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> AudioSample.Builder {
            let resultDecodedBuilder = AudioSample.Builder()
            if let jsonValueImage = jsonMap["image"] as? Dictionary<String,Any> {
                resultDecodedBuilder.image = try Image.Builder.decodeToBuilder(jsonMap:jsonValueImage).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> AudioSample.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try AudioSample.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Av : GeneratedMessage {

    public static func == (lhs: Av, rhs: Av) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasVideo == rhs.hasVideo) && (!lhs.hasVideo || lhs.video == rhs.video)
        fieldCheck = fieldCheck && (lhs.hasAudio == rhs.hasAudio) && (!lhs.hasAudio || lhs.audio == rhs.audio)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var video:VideoSample!
    public fileprivate(set) var hasVideo:Bool = false
    public fileprivate(set) var audio:AudioSample!
    public fileprivate(set) var hasAudio:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasVideo {
            try codedOutputStream.writeMessage(fieldNumber: 1, value:video)
        }
        if hasAudio {
            try codedOutputStream.writeMessage(fieldNumber: 2, value:audio)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasVideo {
            if let varSizevideo = video?.computeMessageSize(fieldNumber: 1) {
                serialize_size += varSizevideo
            }
        }
        if hasAudio {
            if let varSizeaudio = audio?.computeMessageSize(fieldNumber: 2) {
                serialize_size += varSizeaudio
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Av.Builder {
        return Av.classBuilder() as! Av.Builder
    }
    public func getBuilder() -> Av.Builder {
        return classBuilder() as! Av.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Av.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Av.Builder()
    }
    public func toBuilder() throws -> Av.Builder {
        return try Av.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Av) throws -> Av.Builder {
        return try Av.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasVideo {
            jsonMap["video"] = try video.encode()
        }
        if hasAudio {
            jsonMap["audio"] = try audio.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Av {
        return try Av.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Av {
        return try Av.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasVideo {
            output += "\(indent) video {\n"
            if let outDescVideo = video {
                output += try outDescVideo.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasAudio {
            output += "\(indent) audio {\n"
            if let outDescAudio = audio {
                output += try outDescAudio.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVideo {
                if let hashValuevideo = video?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuevideo
                }
            }
            if hasAudio {
                if let hashValueaudio = audio?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueaudio
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Av"
    }
    override public func className() -> String {
        return "Av"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Av = Av()
        public func getMessage() -> Av {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var video:VideoSample! {
            get {
                if videoBuilder_ != nil {
                    builderResult.video = videoBuilder_.getMessage()
                }
                return builderResult.video
            }
            set (value) {
                builderResult.hasVideo = true
                builderResult.video = value
            }
        }
        public var hasVideo:Bool {
            get {
                return builderResult.hasVideo
            }
        }
        fileprivate var videoBuilder_:VideoSample.Builder! {
            didSet {
                builderResult.hasVideo = true
            }
        }
        public func getVideoBuilder() -> VideoSample.Builder {
            if videoBuilder_ == nil {
                videoBuilder_ = VideoSample.Builder()
                builderResult.video = videoBuilder_.getMessage()
                if video != nil {
                    try! videoBuilder_.mergeFrom(other: video)
                }
            }
            return videoBuilder_
        }
        @discardableResult
        public func setVideo(_ value:VideoSample!) -> Av.Builder {
            self.video = value
            return self
        }
        @discardableResult
        public func mergeVideo(value:VideoSample) throws -> Av.Builder {
            if builderResult.hasVideo {
                builderResult.video = try VideoSample.builderWithPrototype(prototype:builderResult.video).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.video = value
            }
            builderResult.hasVideo = true
            return self
        }
        @discardableResult
        public func clearVideo() -> Av.Builder {
            videoBuilder_ = nil
            builderResult.hasVideo = false
            builderResult.video = nil
            return self
        }
        public var audio:AudioSample! {
            get {
                if audioBuilder_ != nil {
                    builderResult.audio = audioBuilder_.getMessage()
                }
                return builderResult.audio
            }
            set (value) {
                builderResult.hasAudio = true
                builderResult.audio = value
            }
        }
        public var hasAudio:Bool {
            get {
                return builderResult.hasAudio
            }
        }
        fileprivate var audioBuilder_:AudioSample.Builder! {
            didSet {
                builderResult.hasAudio = true
            }
        }
        public func getAudioBuilder() -> AudioSample.Builder {
            if audioBuilder_ == nil {
                audioBuilder_ = AudioSample.Builder()
                builderResult.audio = audioBuilder_.getMessage()
                if audio != nil {
                    try! audioBuilder_.mergeFrom(other: audio)
                }
            }
            return audioBuilder_
        }
        @discardableResult
        public func setAudio(_ value:AudioSample!) -> Av.Builder {
            self.audio = value
            return self
        }
        @discardableResult
        public func mergeAudio(value:AudioSample) throws -> Av.Builder {
            if builderResult.hasAudio {
                builderResult.audio = try AudioSample.builderWithPrototype(prototype:builderResult.audio).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.audio = value
            }
            builderResult.hasAudio = true
            return self
        }
        @discardableResult
        public func clearAudio() -> Av.Builder {
            audioBuilder_ = nil
            builderResult.hasAudio = false
            builderResult.audio = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Av.Builder {
            builderResult = Av()
            return self
        }
        override public func clone() throws -> Av.Builder {
            return try Av.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Av {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Av {
            let returnMe:Av = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Av) throws -> Av.Builder {
            if other == Av() {
                return self
            }
            if (other.hasVideo) {
                try mergeVideo(value: other.video)
            }
            if (other.hasAudio) {
                try mergeAudio(value: other.audio)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Av.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Av.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    let subBuilder:VideoSample.Builder = VideoSample.Builder()
                    if hasVideo {
                        try subBuilder.mergeFrom(other: video)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    video = subBuilder.buildPartial()

                case 18:
                    let subBuilder:AudioSample.Builder = AudioSample.Builder()
                    if hasAudio {
                        try subBuilder.mergeFrom(other: audio)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    audio = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Av.Builder {
            let resultDecodedBuilder = Av.Builder()
            if let jsonValueVideo = jsonMap["video"] as? Dictionary<String,Any> {
                resultDecodedBuilder.video = try VideoSample.Builder.decodeToBuilder(jsonMap:jsonValueVideo).build()

            }
            if let jsonValueAudio = jsonMap["audio"] as? Dictionary<String,Any> {
                resultDecodedBuilder.audio = try AudioSample.Builder.decodeToBuilder(jsonMap:jsonValueAudio).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Av.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Av.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Avsession : GeneratedMessage {

    public static func == (lhs: Avsession, rhs: Avsession) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasSid == rhs.hasSid) && (!lhs.hasSid || lhs.sid == rhs.sid)
        fieldCheck = fieldCheck && (lhs.hasGid == rhs.hasGid) && (!lhs.hasGid || lhs.gid == rhs.gid)
        fieldCheck = fieldCheck && (lhs.hasActive == rhs.hasActive) && (!lhs.hasActive || lhs.active == rhs.active)
        fieldCheck = fieldCheck && (lhs.hasData == rhs.hasData) && (!lhs.hasData || lhs.data == rhs.data)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var sid:String! = nil
    public fileprivate(set) var hasSid:Bool = false

    public fileprivate(set) var gid:String! = nil
    public fileprivate(set) var hasGid:Bool = false

    public fileprivate(set) var active:Bool! = nil
    public fileprivate(set) var hasActive:Bool = false

    public fileprivate(set) var data:Data! = nil
    public fileprivate(set) var hasData:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasSid {
            try codedOutputStream.writeString(fieldNumber: 1, value:sid)
        }
        if hasGid {
            try codedOutputStream.writeString(fieldNumber: 2, value:gid)
        }
        if hasActive {
            try codedOutputStream.writeBool(fieldNumber: 3, value:active)
        }
        if hasData {
            try codedOutputStream.writeData(fieldNumber: 4, value:data)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasSid {
            serialize_size += sid.computeStringSize(fieldNumber: 1)
        }
        if hasGid {
            serialize_size += gid.computeStringSize(fieldNumber: 2)
        }
        if hasActive {
            serialize_size += active.computeBoolSize(fieldNumber: 3)
        }
        if hasData {
            serialize_size += data.computeDataSize(fieldNumber: 4)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Avsession.Builder {
        return Avsession.classBuilder() as! Avsession.Builder
    }
    public func getBuilder() -> Avsession.Builder {
        return classBuilder() as! Avsession.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Avsession.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Avsession.Builder()
    }
    public func toBuilder() throws -> Avsession.Builder {
        return try Avsession.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Avsession) throws -> Avsession.Builder {
        return try Avsession.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasSid {
            jsonMap["sid"] = sid
        }
        if hasGid {
            jsonMap["gid"] = gid
        }
        if hasActive {
            jsonMap["active"] = active
        }
        if hasData {
            jsonMap["data"] = data.base64EncodedString(options: Data.Base64EncodingOptions(rawValue: 0))
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Avsession {
        return try Avsession.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Avsession {
        return try Avsession.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasSid {
            output += "\(indent) sid: \(sid) \n"
        }
        if hasGid {
            output += "\(indent) gid: \(gid) \n"
        }
        if hasActive {
            output += "\(indent) active: \(active) \n"
        }
        if hasData {
            output += "\(indent) data: \(data) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasSid {
                hashCode = (hashCode &* 31) &+ sid.hashValue
            }
            if hasGid {
                hashCode = (hashCode &* 31) &+ gid.hashValue
            }
            if hasActive {
                hashCode = (hashCode &* 31) &+ active.hashValue
            }
            if hasData {
                hashCode = (hashCode &* 31) &+ data.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Avsession"
    }
    override public func className() -> String {
        return "Avsession"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Avsession = Avsession()
        public func getMessage() -> Avsession {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var sid:String {
            get {
                return builderResult.sid
            }
            set (value) {
                builderResult.hasSid = true
                builderResult.sid = value
            }
        }
        public var hasSid:Bool {
            get {
                return builderResult.hasSid
            }
        }
        @discardableResult
        public func setSid(_ value:String) -> Avsession.Builder {
            self.sid = value
            return self
        }
        @discardableResult
        public func clearSid() -> Avsession.Builder{
            builderResult.hasSid = false
            builderResult.sid = nil
            return self
        }
        public var gid:String {
            get {
                return builderResult.gid
            }
            set (value) {
                builderResult.hasGid = true
                builderResult.gid = value
            }
        }
        public var hasGid:Bool {
            get {
                return builderResult.hasGid
            }
        }
        @discardableResult
        public func setGid(_ value:String) -> Avsession.Builder {
            self.gid = value
            return self
        }
        @discardableResult
        public func clearGid() -> Avsession.Builder{
            builderResult.hasGid = false
            builderResult.gid = nil
            return self
        }
        public var active:Bool {
            get {
                return builderResult.active
            }
            set (value) {
                builderResult.hasActive = true
                builderResult.active = value
            }
        }
        public var hasActive:Bool {
            get {
                return builderResult.hasActive
            }
        }
        @discardableResult
        public func setActive(_ value:Bool) -> Avsession.Builder {
            self.active = value
            return self
        }
        @discardableResult
        public func clearActive() -> Avsession.Builder{
            builderResult.hasActive = false
            builderResult.active = nil
            return self
        }
        public var data:Data {
            get {
                return builderResult.data
            }
            set (value) {
                builderResult.hasData = true
                builderResult.data = value
            }
        }
        public var hasData:Bool {
            get {
                return builderResult.hasData
            }
        }
        @discardableResult
        public func setData(_ value:Data) -> Avsession.Builder {
            self.data = value
            return self
        }
        @discardableResult
        public func clearData() -> Avsession.Builder{
            builderResult.hasData = false
            builderResult.data = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Avsession.Builder {
            builderResult = Avsession()
            return self
        }
        override public func clone() throws -> Avsession.Builder {
            return try Avsession.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Avsession {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Avsession {
            let returnMe:Avsession = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Avsession) throws -> Avsession.Builder {
            if other == Avsession() {
                return self
            }
            if other.hasSid {
                sid = other.sid
            }
            if other.hasGid {
                gid = other.gid
            }
            if other.hasActive {
                active = other.active
            }
            if other.hasData {
                data = other.data
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Avsession.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Avsession.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 10:
                    sid = try codedInputStream.readString()

                case 18:
                    gid = try codedInputStream.readString()

                case 24:
                    active = try codedInputStream.readBool()

                case 34:
                    data = try codedInputStream.readData()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Avsession.Builder {
            let resultDecodedBuilder = Avsession.Builder()
            if let jsonValueSid = jsonMap["sid"] as? String {
                resultDecodedBuilder.sid = jsonValueSid
            }
            if let jsonValueGid = jsonMap["gid"] as? String {
                resultDecodedBuilder.gid = jsonValueGid
            }
            if let jsonValueActive = jsonMap["active"] as? Bool {
                resultDecodedBuilder.active = jsonValueActive
            }
            if let jsonValueData = jsonMap["data"] as? String {
                resultDecodedBuilder.data = Data(base64Encoded:jsonValueData, options: Data.Base64DecodingOptions(rawValue:0))!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Avsession.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Avsession.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Avquality : GeneratedMessage {

    public static func == (lhs: Avquality, rhs: Avquality) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasDiff == rhs.hasDiff) && (!lhs.hasDiff || lhs.diff == rhs.diff)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }

    public fileprivate(set) var diff:Int32! = nil
    public fileprivate(set) var hasDiff:Bool = false

    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasDiff {
            try codedOutputStream.writeInt32(fieldNumber: 1, value:diff)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasDiff {
            serialize_size += diff.computeInt32Size(fieldNumber: 1)
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Avquality.Builder {
        return Avquality.classBuilder() as! Avquality.Builder
    }
    public func getBuilder() -> Avquality.Builder {
        return classBuilder() as! Avquality.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Avquality.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Avquality.Builder()
    }
    public func toBuilder() throws -> Avquality.Builder {
        return try Avquality.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Avquality) throws -> Avquality.Builder {
        return try Avquality.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasDiff {
            jsonMap["diff"] = Int(diff)
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Avquality {
        return try Avquality.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Avquality {
        return try Avquality.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasDiff {
            output += "\(indent) diff: \(diff) \n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasDiff {
                hashCode = (hashCode &* 31) &+ diff.hashValue
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Avquality"
    }
    override public func className() -> String {
        return "Avquality"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Avquality = Avquality()
        public func getMessage() -> Avquality {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var diff:Int32 {
            get {
                return builderResult.diff
            }
            set (value) {
                builderResult.hasDiff = true
                builderResult.diff = value
            }
        }
        public var hasDiff:Bool {
            get {
                return builderResult.hasDiff
            }
        }
        @discardableResult
        public func setDiff(_ value:Int32) -> Avquality.Builder {
            self.diff = value
            return self
        }
        @discardableResult
        public func clearDiff() -> Avquality.Builder{
            builderResult.hasDiff = false
            builderResult.diff = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Avquality.Builder {
            builderResult = Avquality()
            return self
        }
        override public func clone() throws -> Avquality.Builder {
            return try Avquality.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Avquality {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Avquality {
            let returnMe:Avquality = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Avquality) throws -> Avquality.Builder {
            if other == Avquality() {
                return self
            }
            if other.hasDiff {
                diff = other.diff
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Avquality.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Avquality.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    diff = try codedInputStream.readInt32()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Avquality.Builder {
            let resultDecodedBuilder = Avquality.Builder()
            if let jsonValueDiff = jsonMap["diff"] as? Int {
                resultDecodedBuilder.diff = Int32(jsonValueDiff)
            } else if let jsonValueDiff = jsonMap["diff"] as? String {
                resultDecodedBuilder.diff = Int32(jsonValueDiff)!
            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Avquality.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Avquality.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

final public class Haber : GeneratedMessage {

    public static func == (lhs: Haber, rhs: Haber) -> Bool {
        if lhs === rhs {
            return true
        }
        var fieldCheck:Bool = (lhs.hashValue == rhs.hashValue)
        fieldCheck = fieldCheck && (lhs.hasVersion == rhs.hasVersion) && (!lhs.hasVersion || lhs.version == rhs.version)
        fieldCheck = fieldCheck && (lhs.hasSessionId == rhs.hasSessionId) && (!lhs.hasSessionId || lhs.sessionId == rhs.sessionId)
        fieldCheck = fieldCheck && (lhs.hasFrom == rhs.hasFrom) && (!lhs.hasFrom || lhs.from == rhs.from)
        fieldCheck = fieldCheck && (lhs.hasTo == rhs.hasTo) && (!lhs.hasTo || lhs.to == rhs.to)
        fieldCheck = fieldCheck && (lhs.hasWhich == rhs.hasWhich) && (!lhs.hasWhich || lhs.which == rhs.which)
        fieldCheck = fieldCheck && (lhs.hasLogin == rhs.hasLogin) && (!lhs.hasLogin || lhs.login == rhs.login)
        fieldCheck = fieldCheck && (lhs.contacts == rhs.contacts)
        fieldCheck = fieldCheck && (lhs.hasText == rhs.hasText) && (!lhs.hasText || lhs.text == rhs.text)
        fieldCheck = fieldCheck && (lhs.hasFile == rhs.hasFile) && (!lhs.hasFile || lhs.file == rhs.file)
        fieldCheck = fieldCheck && (lhs.hasCall == rhs.hasCall) && (!lhs.hasCall || lhs.call == rhs.call)
        fieldCheck = fieldCheck && (lhs.hasAv == rhs.hasAv) && (!lhs.hasAv || lhs.av == rhs.av)
        fieldCheck = fieldCheck && (lhs.hasAudioSession == rhs.hasAudioSession) && (!lhs.hasAudioSession || lhs.audioSession == rhs.audioSession)
        fieldCheck = fieldCheck && (lhs.hasVideoSession == rhs.hasVideoSession) && (!lhs.hasVideoSession || lhs.videoSession == rhs.videoSession)
        fieldCheck = fieldCheck && (lhs.hasAvQuality == rhs.hasAvQuality) && (!lhs.hasAvQuality || lhs.avQuality == rhs.avQuality)
        fieldCheck = (fieldCheck && (lhs.unknownFields == rhs.unknownFields))
        return fieldCheck
    }



        //Enum type declaration start 

        /// Identifies which field is filled in
        public enum Which:Int32, GeneratedEnum {
            case login = 0
            case contacts = 1
            case presence = 2
            case text = 3
            case file = 4
            case av = 5
            case audioSession = 6
            case videoSession = 7
            case callProposal = 8
            case callCancel = 9
            case callAccept = 10
            case callDecline = 11
            case callStartOutgoing = 12
            case callStartIncoming = 13
            case callQuality = 14
            case callStop = 15
            public func toString() -> String {
                switch self {
                case .login: return "LOGIN"
                case .contacts: return "CONTACTS"
                case .presence: return "PRESENCE"
                case .text: return "TEXT"
                case .file: return "FILE"
                case .av: return "AV"
                case .audioSession: return "AudioSession"
                case .videoSession: return "VideoSession"
                case .callProposal: return "CALL_PROPOSAL"
                case .callCancel: return "CALL_CANCEL"
                case .callAccept: return "CALL_ACCEPT"
                case .callDecline: return "CALL_DECLINE"
                case .callStartOutgoing: return "CALL_START_OUTGOING"
                case .callStartIncoming: return "CALL_START_INCOMING"
                case .callQuality: return "CALL_QUALITY"
                case .callStop: return "CALL_STOP"
                }
            }
            public static func fromString(_ str:String) throws -> Haber.Which {
                switch str {
                case "LOGIN":    return .login
                case "CONTACTS":    return .contacts
                case "PRESENCE":    return .presence
                case "TEXT":    return .text
                case "FILE":    return .file
                case "AV":    return .av
                case "AudioSession":    return .audioSession
                case "VideoSession":    return .videoSession
                case "CALL_PROPOSAL":    return .callProposal
                case "CALL_CANCEL":    return .callCancel
                case "CALL_ACCEPT":    return .callAccept
                case "CALL_DECLINE":    return .callDecline
                case "CALL_START_OUTGOING":    return .callStartOutgoing
                case "CALL_START_INCOMING":    return .callStartIncoming
                case "CALL_QUALITY":    return .callQuality
                case "CALL_STOP":    return .callStop
                default: throw ProtocolBuffersError.invalidProtocolBuffer("Conversion failed.")
                }
            }
            public var debugDescription:String { return getDescription() }
            public var description:String { return getDescription() }
            private func getDescription() -> String { 
                switch self {
                case .login: return ".login"
                case .contacts: return ".contacts"
                case .presence: return ".presence"
                case .text: return ".text"
                case .file: return ".file"
                case .av: return ".av"
                case .audioSession: return ".audioSession"
                case .videoSession: return ".videoSession"
                case .callProposal: return ".callProposal"
                case .callCancel: return ".callCancel"
                case .callAccept: return ".callAccept"
                case .callDecline: return ".callDecline"
                case .callStartOutgoing: return ".callStartOutgoing"
                case .callStartIncoming: return ".callStartIncoming"
                case .callQuality: return ".callQuality"
                case .callStop: return ".callStop"
                }
            }
            public var hashValue:Int {
                return self.rawValue.hashValue
            }
            public static func ==(lhs:Which, rhs:Which) -> Bool {
                return lhs.hashValue == rhs.hashValue
            }
        }

        //Enum type declaration end 

    public fileprivate(set) var version:UInt32! = nil
    public fileprivate(set) var hasVersion:Bool = false

    public fileprivate(set) var sessionId:String! = nil
    public fileprivate(set) var hasSessionId:Bool = false

    public fileprivate(set) var from:String! = nil
    public fileprivate(set) var hasFrom:Bool = false

    public fileprivate(set) var to:String! = nil
    public fileprivate(set) var hasTo:Bool = false

    public fileprivate(set) var which:Haber.Which = Haber.Which.login
    public fileprivate(set) var hasWhich:Bool = false
    public fileprivate(set) var login:Login!
    public fileprivate(set) var hasLogin:Bool = false
    public fileprivate(set) var contacts:Array<Contact>  = Array<Contact>()
    public fileprivate(set) var text:Text!
    public fileprivate(set) var hasText:Bool = false
    public fileprivate(set) var file:File!
    public fileprivate(set) var hasFile:Bool = false
    public fileprivate(set) var call:Call!
    public fileprivate(set) var hasCall:Bool = false
    public fileprivate(set) var av:Av!
    public fileprivate(set) var hasAv:Bool = false
    public fileprivate(set) var audioSession:Avsession!
    public fileprivate(set) var hasAudioSession:Bool = false
    public fileprivate(set) var videoSession:Avsession!
    public fileprivate(set) var hasVideoSession:Bool = false
    public fileprivate(set) var avQuality:Avquality!
    public fileprivate(set) var hasAvQuality:Bool = false
    required public init() {
        super.init()
    }
    override public func isInitialized() -> Bool {
        return true
    }
    override public func writeTo(codedOutputStream: CodedOutputStream) throws {
        if hasVersion {
            try codedOutputStream.writeUInt32(fieldNumber: 1, value:version)
        }
        if hasSessionId {
            try codedOutputStream.writeString(fieldNumber: 2, value:sessionId)
        }
        if hasFrom {
            try codedOutputStream.writeString(fieldNumber: 3, value:from)
        }
        if hasTo {
            try codedOutputStream.writeString(fieldNumber: 4, value:to)
        }
        if hasWhich {
            try codedOutputStream.writeEnum(fieldNumber: 15, value:which.rawValue)
        }
        if hasLogin {
            try codedOutputStream.writeMessage(fieldNumber: 101, value:login)
        }
        for oneElementContacts in contacts {
              try codedOutputStream.writeMessage(fieldNumber: 102, value:oneElementContacts)
        }
        if hasText {
            try codedOutputStream.writeMessage(fieldNumber: 104, value:text)
        }
        if hasFile {
            try codedOutputStream.writeMessage(fieldNumber: 105, value:file)
        }
        if hasCall {
            try codedOutputStream.writeMessage(fieldNumber: 106, value:call)
        }
        if hasAv {
            try codedOutputStream.writeMessage(fieldNumber: 107, value:av)
        }
        if hasAudioSession {
            try codedOutputStream.writeMessage(fieldNumber: 108, value:audioSession)
        }
        if hasVideoSession {
            try codedOutputStream.writeMessage(fieldNumber: 109, value:videoSession)
        }
        if hasAvQuality {
            try codedOutputStream.writeMessage(fieldNumber: 110, value:avQuality)
        }
        try unknownFields.writeTo(codedOutputStream: codedOutputStream)
    }
    override public func serializedSize() -> Int32 {
        var serialize_size:Int32 = memoizedSerializedSize
        if serialize_size != -1 {
         return serialize_size
        }

        serialize_size = 0
        if hasVersion {
            serialize_size += version.computeUInt32Size(fieldNumber: 1)
        }
        if hasSessionId {
            serialize_size += sessionId.computeStringSize(fieldNumber: 2)
        }
        if hasFrom {
            serialize_size += from.computeStringSize(fieldNumber: 3)
        }
        if hasTo {
            serialize_size += to.computeStringSize(fieldNumber: 4)
        }
        if (hasWhich) {
            serialize_size += which.rawValue.computeEnumSize(fieldNumber: 15)
        }
        if hasLogin {
            if let varSizelogin = login?.computeMessageSize(fieldNumber: 101) {
                serialize_size += varSizelogin
            }
        }
        for oneElementContacts in contacts {
            serialize_size += oneElementContacts.computeMessageSize(fieldNumber: 102)
        }
        if hasText {
            if let varSizetext = text?.computeMessageSize(fieldNumber: 104) {
                serialize_size += varSizetext
            }
        }
        if hasFile {
            if let varSizefile = file?.computeMessageSize(fieldNumber: 105) {
                serialize_size += varSizefile
            }
        }
        if hasCall {
            if let varSizecall = call?.computeMessageSize(fieldNumber: 106) {
                serialize_size += varSizecall
            }
        }
        if hasAv {
            if let varSizeav = av?.computeMessageSize(fieldNumber: 107) {
                serialize_size += varSizeav
            }
        }
        if hasAudioSession {
            if let varSizeaudioSession = audioSession?.computeMessageSize(fieldNumber: 108) {
                serialize_size += varSizeaudioSession
            }
        }
        if hasVideoSession {
            if let varSizevideoSession = videoSession?.computeMessageSize(fieldNumber: 109) {
                serialize_size += varSizevideoSession
            }
        }
        if hasAvQuality {
            if let varSizeavQuality = avQuality?.computeMessageSize(fieldNumber: 110) {
                serialize_size += varSizeavQuality
            }
        }
        serialize_size += unknownFields.serializedSize()
        memoizedSerializedSize = serialize_size
        return serialize_size
    }
    public class func getBuilder() -> Haber.Builder {
        return Haber.classBuilder() as! Haber.Builder
    }
    public func getBuilder() -> Haber.Builder {
        return classBuilder() as! Haber.Builder
    }
    override public class func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Haber.Builder()
    }
    override public func classBuilder() -> ProtocolBuffersMessageBuilder {
        return Haber.Builder()
    }
    public func toBuilder() throws -> Haber.Builder {
        return try Haber.builderWithPrototype(prototype:self)
    }
    public class func builderWithPrototype(prototype:Haber) throws -> Haber.Builder {
        return try Haber.Builder().mergeFrom(other:prototype)
    }
    override public func encode() throws -> Dictionary<String,Any> {
        guard isInitialized() else {
            throw ProtocolBuffersError.invalidProtocolBuffer("Uninitialized Message")
        }

        var jsonMap:Dictionary<String,Any> = Dictionary<String,Any>()
        if hasVersion {
            jsonMap["version"] = UInt(version)
        }
        if hasSessionId {
            jsonMap["sessionId"] = sessionId
        }
        if hasFrom {
            jsonMap["from"] = from
        }
        if hasTo {
            jsonMap["to"] = to
        }
        if hasWhich {
            jsonMap["which"] = which.toString()
        }
        if hasLogin {
            jsonMap["login"] = try login.encode()
        }
        if !contacts.isEmpty {
            var jsonArrayContacts:Array<Dictionary<String,Any>> = []
            for oneValueContacts in contacts {
                let ecodedMessageContacts = try oneValueContacts.encode()
                jsonArrayContacts.append(ecodedMessageContacts)
            }
            jsonMap["contacts"] = jsonArrayContacts
        }
        if hasText {
            jsonMap["text"] = try text.encode()
        }
        if hasFile {
            jsonMap["file"] = try file.encode()
        }
        if hasCall {
            jsonMap["call"] = try call.encode()
        }
        if hasAv {
            jsonMap["av"] = try av.encode()
        }
        if hasAudioSession {
            jsonMap["audioSession"] = try audioSession.encode()
        }
        if hasVideoSession {
            jsonMap["videoSession"] = try videoSession.encode()
        }
        if hasAvQuality {
            jsonMap["avQuality"] = try avQuality.encode()
        }
        return jsonMap
    }
    override class public func decode(jsonMap:Dictionary<String,Any>) throws -> Haber {
        return try Haber.Builder.decodeToBuilder(jsonMap:jsonMap).build()
    }
    override class public func fromJSON(data:Data) throws -> Haber {
        return try Haber.Builder.fromJSONToBuilder(data:data).build()
    }
    override public func getDescription(indent:String) throws -> String {
        var output = ""
        if hasVersion {
            output += "\(indent) version: \(version) \n"
        }
        if hasSessionId {
            output += "\(indent) sessionId: \(sessionId) \n"
        }
        if hasFrom {
            output += "\(indent) from: \(from) \n"
        }
        if hasTo {
            output += "\(indent) to: \(to) \n"
        }
        if (hasWhich) {
            output += "\(indent) which: \(which.description)\n"
        }
        if hasLogin {
            output += "\(indent) login {\n"
            if let outDescLogin = login {
                output += try outDescLogin.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        var contactsElementIndex:Int = 0
        for oneElementContacts in contacts {
            output += "\(indent) contacts[\(contactsElementIndex)] {\n"
            output += try oneElementContacts.getDescription(indent: "\(indent)  ")
            output += "\(indent)}\n"
            contactsElementIndex += 1
        }
        if hasText {
            output += "\(indent) text {\n"
            if let outDescText = text {
                output += try outDescText.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasFile {
            output += "\(indent) file {\n"
            if let outDescFile = file {
                output += try outDescFile.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasCall {
            output += "\(indent) call {\n"
            if let outDescCall = call {
                output += try outDescCall.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasAv {
            output += "\(indent) av {\n"
            if let outDescAv = av {
                output += try outDescAv.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasAudioSession {
            output += "\(indent) audioSession {\n"
            if let outDescAudioSession = audioSession {
                output += try outDescAudioSession.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasVideoSession {
            output += "\(indent) videoSession {\n"
            if let outDescVideoSession = videoSession {
                output += try outDescVideoSession.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        if hasAvQuality {
            output += "\(indent) avQuality {\n"
            if let outDescAvQuality = avQuality {
                output += try outDescAvQuality.getDescription(indent: "\(indent)  ")
            }
            output += "\(indent) }\n"
        }
        output += unknownFields.getDescription(indent: indent)
        return output
    }
    override public var hashValue:Int {
        get {
            var hashCode:Int = 7
            if hasVersion {
                hashCode = (hashCode &* 31) &+ version.hashValue
            }
            if hasSessionId {
                hashCode = (hashCode &* 31) &+ sessionId.hashValue
            }
            if hasFrom {
                hashCode = (hashCode &* 31) &+ from.hashValue
            }
            if hasTo {
                hashCode = (hashCode &* 31) &+ to.hashValue
            }
            if hasWhich {
                 hashCode = (hashCode &* 31) &+ which.hashValue
            }
            if hasLogin {
                if let hashValuelogin = login?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuelogin
                }
            }
            for oneElementContacts in contacts {
                hashCode = (hashCode &* 31) &+ oneElementContacts.hashValue
            }
            if hasText {
                if let hashValuetext = text?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuetext
                }
            }
            if hasFile {
                if let hashValuefile = file?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuefile
                }
            }
            if hasCall {
                if let hashValuecall = call?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuecall
                }
            }
            if hasAv {
                if let hashValueav = av?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueav
                }
            }
            if hasAudioSession {
                if let hashValueaudioSession = audioSession?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueaudioSession
                }
            }
            if hasVideoSession {
                if let hashValuevideoSession = videoSession?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValuevideoSession
                }
            }
            if hasAvQuality {
                if let hashValueavQuality = avQuality?.hashValue {
                    hashCode = (hashCode &* 31) &+ hashValueavQuality
                }
            }
            hashCode = (hashCode &* 31) &+  unknownFields.hashValue
            return hashCode
        }
    }


    //Meta information declaration start

    override public class func className() -> String {
        return "Haber"
    }
    override public func className() -> String {
        return "Haber"
    }
    //Meta information declaration end

    final public class Builder : GeneratedMessageBuilder {
        fileprivate var builderResult:Haber = Haber()
        public func getMessage() -> Haber {
            return builderResult
        }

        required override public init () {
            super.init()
        }
        public var version:UInt32 {
            get {
                return builderResult.version
            }
            set (value) {
                builderResult.hasVersion = true
                builderResult.version = value
            }
        }
        public var hasVersion:Bool {
            get {
                return builderResult.hasVersion
            }
        }
        @discardableResult
        public func setVersion(_ value:UInt32) -> Haber.Builder {
            self.version = value
            return self
        }
        @discardableResult
        public func clearVersion() -> Haber.Builder{
            builderResult.hasVersion = false
            builderResult.version = nil
            return self
        }
        public var sessionId:String {
            get {
                return builderResult.sessionId
            }
            set (value) {
                builderResult.hasSessionId = true
                builderResult.sessionId = value
            }
        }
        public var hasSessionId:Bool {
            get {
                return builderResult.hasSessionId
            }
        }
        @discardableResult
        public func setSessionId(_ value:String) -> Haber.Builder {
            self.sessionId = value
            return self
        }
        @discardableResult
        public func clearSessionId() -> Haber.Builder{
            builderResult.hasSessionId = false
            builderResult.sessionId = nil
            return self
        }
        public var from:String {
            get {
                return builderResult.from
            }
            set (value) {
                builderResult.hasFrom = true
                builderResult.from = value
            }
        }
        public var hasFrom:Bool {
            get {
                return builderResult.hasFrom
            }
        }
        @discardableResult
        public func setFrom(_ value:String) -> Haber.Builder {
            self.from = value
            return self
        }
        @discardableResult
        public func clearFrom() -> Haber.Builder{
            builderResult.hasFrom = false
            builderResult.from = nil
            return self
        }
        public var to:String {
            get {
                return builderResult.to
            }
            set (value) {
                builderResult.hasTo = true
                builderResult.to = value
            }
        }
        public var hasTo:Bool {
            get {
                return builderResult.hasTo
            }
        }
        @discardableResult
        public func setTo(_ value:String) -> Haber.Builder {
            self.to = value
            return self
        }
        @discardableResult
        public func clearTo() -> Haber.Builder{
            builderResult.hasTo = false
            builderResult.to = nil
            return self
        }
            public var which:Haber.Which {
                get {
                    return builderResult.which
                }
                set (value) {
                    builderResult.hasWhich = true
                    builderResult.which = value
                }
            }
            public var hasWhich:Bool{
                get {
                    return builderResult.hasWhich
                }
            }
        @discardableResult
            public func setWhich(_ value:Haber.Which) -> Haber.Builder {
              self.which = value
              return self
            }
        @discardableResult
            public func clearWhich() -> Haber.Builder {
               builderResult.hasWhich = false
               builderResult.which = .login
               return self
            }
        /// One of the following will be filled in
        public var login:Login! {
            get {
                if loginBuilder_ != nil {
                    builderResult.login = loginBuilder_.getMessage()
                }
                return builderResult.login
            }
            set (value) {
                builderResult.hasLogin = true
                builderResult.login = value
            }
        }
        public var hasLogin:Bool {
            get {
                return builderResult.hasLogin
            }
        }
        fileprivate var loginBuilder_:Login.Builder! {
            didSet {
                builderResult.hasLogin = true
            }
        }
        public func getLoginBuilder() -> Login.Builder {
            if loginBuilder_ == nil {
                loginBuilder_ = Login.Builder()
                builderResult.login = loginBuilder_.getMessage()
                if login != nil {
                    try! loginBuilder_.mergeFrom(other: login)
                }
            }
            return loginBuilder_
        }
        @discardableResult
        public func setLogin(_ value:Login!) -> Haber.Builder {
            self.login = value
            return self
        }
        @discardableResult
        public func mergeLogin(value:Login) throws -> Haber.Builder {
            if builderResult.hasLogin {
                builderResult.login = try Login.builderWithPrototype(prototype:builderResult.login).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.login = value
            }
            builderResult.hasLogin = true
            return self
        }
        @discardableResult
        public func clearLogin() -> Haber.Builder {
            loginBuilder_ = nil
            builderResult.hasLogin = false
            builderResult.login = nil
            return self
        }
        /// for roster, presence, and invite
        public var contacts:Array<Contact> {
            get {
                return builderResult.contacts
            }
            set (value) {
                builderResult.contacts = value
            }
        }
        @discardableResult
        public func setContacts(_ value:Array<Contact>) -> Haber.Builder {
            self.contacts = value
            return self
        }
        @discardableResult
        public func clearContacts() -> Haber.Builder {
            builderResult.contacts.removeAll(keepingCapacity: false)
            return self
        }
        public var text:Text! {
            get {
                if textBuilder_ != nil {
                    builderResult.text = textBuilder_.getMessage()
                }
                return builderResult.text
            }
            set (value) {
                builderResult.hasText = true
                builderResult.text = value
            }
        }
        public var hasText:Bool {
            get {
                return builderResult.hasText
            }
        }
        fileprivate var textBuilder_:Text.Builder! {
            didSet {
                builderResult.hasText = true
            }
        }
        public func getTextBuilder() -> Text.Builder {
            if textBuilder_ == nil {
                textBuilder_ = Text.Builder()
                builderResult.text = textBuilder_.getMessage()
                if text != nil {
                    try! textBuilder_.mergeFrom(other: text)
                }
            }
            return textBuilder_
        }
        @discardableResult
        public func setText(_ value:Text!) -> Haber.Builder {
            self.text = value
            return self
        }
        @discardableResult
        public func mergeText(value:Text) throws -> Haber.Builder {
            if builderResult.hasText {
                builderResult.text = try Text.builderWithPrototype(prototype:builderResult.text).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.text = value
            }
            builderResult.hasText = true
            return self
        }
        @discardableResult
        public func clearText() -> Haber.Builder {
            textBuilder_ = nil
            builderResult.hasText = false
            builderResult.text = nil
            return self
        }
        public var file:File! {
            get {
                if fileBuilder_ != nil {
                    builderResult.file = fileBuilder_.getMessage()
                }
                return builderResult.file
            }
            set (value) {
                builderResult.hasFile = true
                builderResult.file = value
            }
        }
        public var hasFile:Bool {
            get {
                return builderResult.hasFile
            }
        }
        fileprivate var fileBuilder_:File.Builder! {
            didSet {
                builderResult.hasFile = true
            }
        }
        public func getFileBuilder() -> File.Builder {
            if fileBuilder_ == nil {
                fileBuilder_ = File.Builder()
                builderResult.file = fileBuilder_.getMessage()
                if file != nil {
                    try! fileBuilder_.mergeFrom(other: file)
                }
            }
            return fileBuilder_
        }
        @discardableResult
        public func setFile(_ value:File!) -> Haber.Builder {
            self.file = value
            return self
        }
        @discardableResult
        public func mergeFile(value:File) throws -> Haber.Builder {
            if builderResult.hasFile {
                builderResult.file = try File.builderWithPrototype(prototype:builderResult.file).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.file = value
            }
            builderResult.hasFile = true
            return self
        }
        @discardableResult
        public func clearFile() -> Haber.Builder {
            fileBuilder_ = nil
            builderResult.hasFile = false
            builderResult.file = nil
            return self
        }
        public var call:Call! {
            get {
                if callBuilder_ != nil {
                    builderResult.call = callBuilder_.getMessage()
                }
                return builderResult.call
            }
            set (value) {
                builderResult.hasCall = true
                builderResult.call = value
            }
        }
        public var hasCall:Bool {
            get {
                return builderResult.hasCall
            }
        }
        fileprivate var callBuilder_:Call.Builder! {
            didSet {
                builderResult.hasCall = true
            }
        }
        public func getCallBuilder() -> Call.Builder {
            if callBuilder_ == nil {
                callBuilder_ = Call.Builder()
                builderResult.call = callBuilder_.getMessage()
                if call != nil {
                    try! callBuilder_.mergeFrom(other: call)
                }
            }
            return callBuilder_
        }
        @discardableResult
        public func setCall(_ value:Call!) -> Haber.Builder {
            self.call = value
            return self
        }
        @discardableResult
        public func mergeCall(value:Call) throws -> Haber.Builder {
            if builderResult.hasCall {
                builderResult.call = try Call.builderWithPrototype(prototype:builderResult.call).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.call = value
            }
            builderResult.hasCall = true
            return self
        }
        @discardableResult
        public func clearCall() -> Haber.Builder {
            callBuilder_ = nil
            builderResult.hasCall = false
            builderResult.call = nil
            return self
        }
        public var av:Av! {
            get {
                if avBuilder_ != nil {
                    builderResult.av = avBuilder_.getMessage()
                }
                return builderResult.av
            }
            set (value) {
                builderResult.hasAv = true
                builderResult.av = value
            }
        }
        public var hasAv:Bool {
            get {
                return builderResult.hasAv
            }
        }
        fileprivate var avBuilder_:Av.Builder! {
            didSet {
                builderResult.hasAv = true
            }
        }
        public func getAvBuilder() -> Av.Builder {
            if avBuilder_ == nil {
                avBuilder_ = Av.Builder()
                builderResult.av = avBuilder_.getMessage()
                if av != nil {
                    try! avBuilder_.mergeFrom(other: av)
                }
            }
            return avBuilder_
        }
        @discardableResult
        public func setAv(_ value:Av!) -> Haber.Builder {
            self.av = value
            return self
        }
        @discardableResult
        public func mergeAv(value:Av) throws -> Haber.Builder {
            if builderResult.hasAv {
                builderResult.av = try Av.builderWithPrototype(prototype:builderResult.av).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.av = value
            }
            builderResult.hasAv = true
            return self
        }
        @discardableResult
        public func clearAv() -> Haber.Builder {
            avBuilder_ = nil
            builderResult.hasAv = false
            builderResult.av = nil
            return self
        }
        public var audioSession:Avsession! {
            get {
                if audioSessionBuilder_ != nil {
                    builderResult.audioSession = audioSessionBuilder_.getMessage()
                }
                return builderResult.audioSession
            }
            set (value) {
                builderResult.hasAudioSession = true
                builderResult.audioSession = value
            }
        }
        public var hasAudioSession:Bool {
            get {
                return builderResult.hasAudioSession
            }
        }
        fileprivate var audioSessionBuilder_:Avsession.Builder! {
            didSet {
                builderResult.hasAudioSession = true
            }
        }
        public func getAudioSessionBuilder() -> Avsession.Builder {
            if audioSessionBuilder_ == nil {
                audioSessionBuilder_ = Avsession.Builder()
                builderResult.audioSession = audioSessionBuilder_.getMessage()
                if audioSession != nil {
                    try! audioSessionBuilder_.mergeFrom(other: audioSession)
                }
            }
            return audioSessionBuilder_
        }
        @discardableResult
        public func setAudioSession(_ value:Avsession!) -> Haber.Builder {
            self.audioSession = value
            return self
        }
        @discardableResult
        public func mergeAudioSession(value:Avsession) throws -> Haber.Builder {
            if builderResult.hasAudioSession {
                builderResult.audioSession = try Avsession.builderWithPrototype(prototype:builderResult.audioSession).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.audioSession = value
            }
            builderResult.hasAudioSession = true
            return self
        }
        @discardableResult
        public func clearAudioSession() -> Haber.Builder {
            audioSessionBuilder_ = nil
            builderResult.hasAudioSession = false
            builderResult.audioSession = nil
            return self
        }
        public var videoSession:Avsession! {
            get {
                if videoSessionBuilder_ != nil {
                    builderResult.videoSession = videoSessionBuilder_.getMessage()
                }
                return builderResult.videoSession
            }
            set (value) {
                builderResult.hasVideoSession = true
                builderResult.videoSession = value
            }
        }
        public var hasVideoSession:Bool {
            get {
                return builderResult.hasVideoSession
            }
        }
        fileprivate var videoSessionBuilder_:Avsession.Builder! {
            didSet {
                builderResult.hasVideoSession = true
            }
        }
        public func getVideoSessionBuilder() -> Avsession.Builder {
            if videoSessionBuilder_ == nil {
                videoSessionBuilder_ = Avsession.Builder()
                builderResult.videoSession = videoSessionBuilder_.getMessage()
                if videoSession != nil {
                    try! videoSessionBuilder_.mergeFrom(other: videoSession)
                }
            }
            return videoSessionBuilder_
        }
        @discardableResult
        public func setVideoSession(_ value:Avsession!) -> Haber.Builder {
            self.videoSession = value
            return self
        }
        @discardableResult
        public func mergeVideoSession(value:Avsession) throws -> Haber.Builder {
            if builderResult.hasVideoSession {
                builderResult.videoSession = try Avsession.builderWithPrototype(prototype:builderResult.videoSession).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.videoSession = value
            }
            builderResult.hasVideoSession = true
            return self
        }
        @discardableResult
        public func clearVideoSession() -> Haber.Builder {
            videoSessionBuilder_ = nil
            builderResult.hasVideoSession = false
            builderResult.videoSession = nil
            return self
        }
        public var avQuality:Avquality! {
            get {
                if avQualityBuilder_ != nil {
                    builderResult.avQuality = avQualityBuilder_.getMessage()
                }
                return builderResult.avQuality
            }
            set (value) {
                builderResult.hasAvQuality = true
                builderResult.avQuality = value
            }
        }
        public var hasAvQuality:Bool {
            get {
                return builderResult.hasAvQuality
            }
        }
        fileprivate var avQualityBuilder_:Avquality.Builder! {
            didSet {
                builderResult.hasAvQuality = true
            }
        }
        public func getAvQualityBuilder() -> Avquality.Builder {
            if avQualityBuilder_ == nil {
                avQualityBuilder_ = Avquality.Builder()
                builderResult.avQuality = avQualityBuilder_.getMessage()
                if avQuality != nil {
                    try! avQualityBuilder_.mergeFrom(other: avQuality)
                }
            }
            return avQualityBuilder_
        }
        @discardableResult
        public func setAvQuality(_ value:Avquality!) -> Haber.Builder {
            self.avQuality = value
            return self
        }
        @discardableResult
        public func mergeAvQuality(value:Avquality) throws -> Haber.Builder {
            if builderResult.hasAvQuality {
                builderResult.avQuality = try Avquality.builderWithPrototype(prototype:builderResult.avQuality).mergeFrom(other: value).buildPartial()
            } else {
                builderResult.avQuality = value
            }
            builderResult.hasAvQuality = true
            return self
        }
        @discardableResult
        public func clearAvQuality() -> Haber.Builder {
            avQualityBuilder_ = nil
            builderResult.hasAvQuality = false
            builderResult.avQuality = nil
            return self
        }
        override public var internalGetResult:GeneratedMessage {
            get {
                return builderResult
            }
        }
        @discardableResult
        override public func clear() -> Haber.Builder {
            builderResult = Haber()
            return self
        }
        override public func clone() throws -> Haber.Builder {
            return try Haber.builderWithPrototype(prototype:builderResult)
        }
        override public func build() throws -> Haber {
            try checkInitialized()
            return buildPartial()
        }
        public func buildPartial() -> Haber {
            let returnMe:Haber = builderResult
            return returnMe
        }
        @discardableResult
        public func mergeFrom(other:Haber) throws -> Haber.Builder {
            if other == Haber() {
                return self
            }
            if other.hasVersion {
                version = other.version
            }
            if other.hasSessionId {
                sessionId = other.sessionId
            }
            if other.hasFrom {
                from = other.from
            }
            if other.hasTo {
                to = other.to
            }
            if other.hasWhich {
                which = other.which
            }
            if (other.hasLogin) {
                try mergeLogin(value: other.login)
            }
            if !other.contacts.isEmpty  {
                 builderResult.contacts += other.contacts
            }
            if (other.hasText) {
                try mergeText(value: other.text)
            }
            if (other.hasFile) {
                try mergeFile(value: other.file)
            }
            if (other.hasCall) {
                try mergeCall(value: other.call)
            }
            if (other.hasAv) {
                try mergeAv(value: other.av)
            }
            if (other.hasAudioSession) {
                try mergeAudioSession(value: other.audioSession)
            }
            if (other.hasVideoSession) {
                try mergeVideoSession(value: other.videoSession)
            }
            if (other.hasAvQuality) {
                try mergeAvQuality(value: other.avQuality)
            }
            try merge(unknownField: other.unknownFields)
            return self
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream) throws -> Haber.Builder {
            return try mergeFrom(codedInputStream: codedInputStream, extensionRegistry:ExtensionRegistry())
        }
        @discardableResult
        override public func mergeFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Haber.Builder {
            let unknownFieldsBuilder:UnknownFieldSet.Builder = try UnknownFieldSet.builderWithUnknownFields(copyFrom:self.unknownFields)
            while (true) {
                let protobufTag = try codedInputStream.readTag()
                switch protobufTag {
                case 0: 
                    self.unknownFields = try unknownFieldsBuilder.build()
                    return self

                case 8:
                    version = try codedInputStream.readUInt32()

                case 18:
                    sessionId = try codedInputStream.readString()

                case 26:
                    from = try codedInputStream.readString()

                case 34:
                    to = try codedInputStream.readString()

                case 120:
                    let valueIntwhich = try codedInputStream.readEnum()
                    if let enumswhich = Haber.Which(rawValue:valueIntwhich){
                        which = enumswhich
                    } else {
                        try unknownFieldsBuilder.mergeVarintField(fieldNumber: 15, value:Int64(valueIntwhich))
                    }

                case 810:
                    let subBuilder:Login.Builder = Login.Builder()
                    if hasLogin {
                        try subBuilder.mergeFrom(other: login)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    login = subBuilder.buildPartial()

                case 818:
                    let subBuilder = Contact.Builder()
                    try codedInputStream.readMessage(builder: subBuilder,extensionRegistry:extensionRegistry)
                    contacts.append(subBuilder.buildPartial())

                case 834:
                    let subBuilder:Text.Builder = Text.Builder()
                    if hasText {
                        try subBuilder.mergeFrom(other: text)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    text = subBuilder.buildPartial()

                case 842:
                    let subBuilder:File.Builder = File.Builder()
                    if hasFile {
                        try subBuilder.mergeFrom(other: file)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    file = subBuilder.buildPartial()

                case 850:
                    let subBuilder:Call.Builder = Call.Builder()
                    if hasCall {
                        try subBuilder.mergeFrom(other: call)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    call = subBuilder.buildPartial()

                case 858:
                    let subBuilder:Av.Builder = Av.Builder()
                    if hasAv {
                        try subBuilder.mergeFrom(other: av)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    av = subBuilder.buildPartial()

                case 866:
                    let subBuilder:Avsession.Builder = Avsession.Builder()
                    if hasAudioSession {
                        try subBuilder.mergeFrom(other: audioSession)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    audioSession = subBuilder.buildPartial()

                case 874:
                    let subBuilder:Avsession.Builder = Avsession.Builder()
                    if hasVideoSession {
                        try subBuilder.mergeFrom(other: videoSession)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    videoSession = subBuilder.buildPartial()

                case 882:
                    let subBuilder:Avquality.Builder = Avquality.Builder()
                    if hasAvQuality {
                        try subBuilder.mergeFrom(other: avQuality)
                    }
                    try codedInputStream.readMessage(builder: subBuilder, extensionRegistry:extensionRegistry)
                    avQuality = subBuilder.buildPartial()

                default:
                    if (!(try parse(codedInputStream:codedInputStream, unknownFields:unknownFieldsBuilder, extensionRegistry:extensionRegistry, tag:protobufTag))) {
                        unknownFields = try unknownFieldsBuilder.build()
                        return self
                    }
                }
            }
        }
        class override public func decodeToBuilder(jsonMap:Dictionary<String,Any>) throws -> Haber.Builder {
            let resultDecodedBuilder = Haber.Builder()
            if let jsonValueVersion = jsonMap["version"] as? UInt {
                resultDecodedBuilder.version = UInt32(jsonValueVersion)
            } else if let jsonValueVersion = jsonMap["version"] as? String {
                resultDecodedBuilder.version = UInt32(jsonValueVersion)!
            }
            if let jsonValueSessionId = jsonMap["sessionId"] as? String {
                resultDecodedBuilder.sessionId = jsonValueSessionId
            }
            if let jsonValueFrom = jsonMap["from"] as? String {
                resultDecodedBuilder.from = jsonValueFrom
            }
            if let jsonValueTo = jsonMap["to"] as? String {
                resultDecodedBuilder.to = jsonValueTo
            }
            if let jsonValueWhich = jsonMap["which"] as? String {
                resultDecodedBuilder.which = try Haber.Which.fromString(jsonValueWhich)
            }
            if let jsonValueLogin = jsonMap["login"] as? Dictionary<String,Any> {
                resultDecodedBuilder.login = try Login.Builder.decodeToBuilder(jsonMap:jsonValueLogin).build()

            }
            if let jsonValueContacts = jsonMap["contacts"] as? Array<Dictionary<String,Any>> {
                var jsonArrayContacts:Array<Contact> = []
                for oneValueContacts in jsonValueContacts {
                    let messageFromStringContacts = try Contact.Builder.decodeToBuilder(jsonMap:oneValueContacts).build()

                    jsonArrayContacts.append(messageFromStringContacts)
                }
                resultDecodedBuilder.contacts = jsonArrayContacts
            }
            if let jsonValueText = jsonMap["text"] as? Dictionary<String,Any> {
                resultDecodedBuilder.text = try Text.Builder.decodeToBuilder(jsonMap:jsonValueText).build()

            }
            if let jsonValueFile = jsonMap["file"] as? Dictionary<String,Any> {
                resultDecodedBuilder.file = try File.Builder.decodeToBuilder(jsonMap:jsonValueFile).build()

            }
            if let jsonValueCall = jsonMap["call"] as? Dictionary<String,Any> {
                resultDecodedBuilder.call = try Call.Builder.decodeToBuilder(jsonMap:jsonValueCall).build()

            }
            if let jsonValueAv = jsonMap["av"] as? Dictionary<String,Any> {
                resultDecodedBuilder.av = try Av.Builder.decodeToBuilder(jsonMap:jsonValueAv).build()

            }
            if let jsonValueAudioSession = jsonMap["audioSession"] as? Dictionary<String,Any> {
                resultDecodedBuilder.audioSession = try Avsession.Builder.decodeToBuilder(jsonMap:jsonValueAudioSession).build()

            }
            if let jsonValueVideoSession = jsonMap["videoSession"] as? Dictionary<String,Any> {
                resultDecodedBuilder.videoSession = try Avsession.Builder.decodeToBuilder(jsonMap:jsonValueVideoSession).build()

            }
            if let jsonValueAvQuality = jsonMap["avQuality"] as? Dictionary<String,Any> {
                resultDecodedBuilder.avQuality = try Avquality.Builder.decodeToBuilder(jsonMap:jsonValueAvQuality).build()

            }
            return resultDecodedBuilder
        }
        override class public func fromJSONToBuilder(data:Data) throws -> Haber.Builder {
            let jsonData = try JSONSerialization.jsonObject(with:data, options: JSONSerialization.ReadingOptions(rawValue: 0))
            guard let jsDataCast = jsonData as? Dictionary<String,Any> else {
              throw ProtocolBuffersError.invalidProtocolBuffer("Invalid JSON data")
            }
            return try Haber.Builder.decodeToBuilder(jsonMap:jsDataCast)
        }
    }

}

extension Login: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Login> {
        var mergedArray = Array<Login>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Login? {
        return try Login.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Login {
        return try Login.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Login {
        return try Login.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Login {
        return try Login.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Login {
        return try Login.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Login {
        return try Login.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Login {
        return try Login.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "username": return self.username
        default: return nil
        }
    }
}
extension Login.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "username": return self.username
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "username":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.username = newSubscriptValue
            default: return
            }
        }
    }
}
extension Contact: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Contact> {
        var mergedArray = Array<Contact>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Contact? {
        return try Contact.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Contact {
        return try Contact.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Contact {
        return try Contact.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Contact {
        return try Contact.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Contact {
        return try Contact.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Contact {
        return try Contact.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Contact {
        return try Contact.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "name": return self.name
        case "online": return self.online
        default: return nil
        }
    }
}
extension Contact.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "name": return self.name
            case "online": return self.online
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "name":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.name = newSubscriptValue
            case "online":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.online = newSubscriptValue
            default: return
            }
        }
    }
}
extension Text: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Text> {
        var mergedArray = Array<Text>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Text? {
        return try Text.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Text {
        return try Text.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Text {
        return try Text.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Text {
        return try Text.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Text {
        return try Text.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Text {
        return try Text.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Text {
        return try Text.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "body": return self.body
        default: return nil
        }
    }
}
extension Text.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "body": return self.body
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "body":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.body = newSubscriptValue
            default: return
            }
        }
    }
}
extension File: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<File> {
        var mergedArray = Array<File>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> File? {
        return try File.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> File {
        return try File.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> File {
        return try File.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> File {
        return try File.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> File {
        return try File.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> File {
        return try File.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> File {
        return try File.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "data": return self.data
        default: return nil
        }
    }
}
extension File.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Call: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Call> {
        var mergedArray = Array<Call>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Call? {
        return try Call.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Call {
        return try Call.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Call {
        return try Call.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Call {
        return try Call.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Call {
        return try Call.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Call {
        return try Call.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Call {
        return try Call.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "to": return self.to
        case "from": return self.from
        case "audio": return self.audio
        case "video": return self.video
        default: return nil
        }
    }
}
extension Call.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "to": return self.to
            case "from": return self.from
            case "audio": return self.audio
            case "video": return self.video
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "to":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.to = newSubscriptValue
            case "from":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.from = newSubscriptValue
            case "audio":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.audio = newSubscriptValue
            case "video":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.video = newSubscriptValue
            default: return
            }
        }
    }
}
extension Time: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Time> {
        var mergedArray = Array<Time>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Time? {
        return try Time.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Time {
        return try Time.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Time {
        return try Time.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Time {
        return try Time.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Time {
        return try Time.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Time {
        return try Time.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Time {
        return try Time.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "value": return self.value
        case "scale": return self.scale
        case "flags": return self.flags
        case "epoch": return self.epoch
        default: return nil
        }
    }
}
extension Time.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "value": return self.value
            case "scale": return self.scale
            case "flags": return self.flags
            case "epoch": return self.epoch
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.value = newSubscriptValue
            case "scale":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.scale = newSubscriptValue
            case "flags":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.flags = newSubscriptValue
            case "epoch":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.epoch = newSubscriptValue
            default: return
            }
        }
    }
}
extension Timestamp: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Timestamp> {
        var mergedArray = Array<Timestamp>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Timestamp? {
        return try Timestamp.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Timestamp {
        return try Timestamp.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Timestamp {
        return try Timestamp.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Timestamp {
        return try Timestamp.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Timestamp {
        return try Timestamp.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Timestamp {
        return try Timestamp.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Timestamp {
        return try Timestamp.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "duration": return self.duration
        case "presentation": return self.presentation
        default: return nil
        }
    }
}
extension Timestamp.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "duration": return self.duration
            case "presentation": return self.presentation
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "duration":
                guard let newSubscriptValue = newSubscriptValue as? Time else {
                    return
                }
                self.duration = newSubscriptValue
            case "presentation":
                guard let newSubscriptValue = newSubscriptValue as? Time else {
                    return
                }
                self.presentation = newSubscriptValue
            default: return
            }
        }
    }
}
extension Image: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Image> {
        var mergedArray = Array<Image>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Image? {
        return try Image.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Image {
        return try Image.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Image {
        return try Image.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Image {
        return try Image.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Image {
        return try Image.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Image {
        return try Image.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Image {
        return try Image.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "width": return self.width
        case "height": return self.height
        case "format": return self.format
        case "attachments": return self.attachments
        case "data": return self.data
        default: return nil
        }
    }
}
extension Image.AttachmentsEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Image.AttachmentsEntry> {
        var mergedArray = Array<Image.AttachmentsEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Image.AttachmentsEntry? {
        return try Image.AttachmentsEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Image.AttachmentsEntry {
        return try Image.AttachmentsEntry.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Image.AttachmentsEntry {
        return try Image.AttachmentsEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Image.AttachmentsEntry {
        return try Image.AttachmentsEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Image.AttachmentsEntry {
        return try Image.AttachmentsEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Image.AttachmentsEntry {
        return try Image.AttachmentsEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Image.AttachmentsEntry {
        return try Image.AttachmentsEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension Image.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "width": return self.width
            case "height": return self.height
            case "format": return self.format
            case "attachments": return self.attachments
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "width":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.width = newSubscriptValue
            case "height":
                guard let newSubscriptValue = newSubscriptValue as? Int64 else {
                    return
                }
                self.height = newSubscriptValue
            case "format":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.format = newSubscriptValue
            case "attachments":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.attachments = newSubscriptValue
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Image.AttachmentsEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension FormatDescription: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<FormatDescription> {
        var mergedArray = Array<FormatDescription>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> FormatDescription? {
        return try FormatDescription.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> FormatDescription {
        return try FormatDescription.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> FormatDescription {
        return try FormatDescription.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> FormatDescription {
        return try FormatDescription.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> FormatDescription {
        return try FormatDescription.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> FormatDescription {
        return try FormatDescription.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> FormatDescription {
        return try FormatDescription.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "mediaType": return self.mediaType
        case "mediaSubtype": return self.mediaSubtype
        case "extensions": return self.extensions
        default: return nil
        }
    }
}
extension FormatDescription.ExtensionsEntry: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<FormatDescription.ExtensionsEntry> {
        var mergedArray = Array<FormatDescription.ExtensionsEntry>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> FormatDescription.ExtensionsEntry? {
        return try FormatDescription.ExtensionsEntry.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> FormatDescription.ExtensionsEntry {
        return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> FormatDescription.ExtensionsEntry {
        return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> FormatDescription.ExtensionsEntry {
        return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> FormatDescription.ExtensionsEntry {
        return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> FormatDescription.ExtensionsEntry {
        return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> FormatDescription.ExtensionsEntry {
        return try FormatDescription.ExtensionsEntry.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "key": return self.key
        case "value": return self.value
        default: return nil
        }
    }
}
extension FormatDescription.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "mediaType": return self.mediaType
            case "mediaSubtype": return self.mediaSubtype
            case "extensions": return self.extensions
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "mediaType":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.mediaType = newSubscriptValue
            case "mediaSubtype":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.mediaSubtype = newSubscriptValue
            case "extensions":
                guard let newSubscriptValue = newSubscriptValue as? Dictionary<String,String> else {
                    return
                }
                self.extensions = newSubscriptValue
            default: return
            }
        }
    }
}
extension FormatDescription.ExtensionsEntry.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "key": return self.key
            case "value": return self.value
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "key":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.key = newSubscriptValue
            case "value":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.value = newSubscriptValue
            default: return
            }
        }
    }
}
extension VideoSample: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<VideoSample> {
        var mergedArray = Array<VideoSample>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> VideoSample? {
        return try VideoSample.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> VideoSample {
        return try VideoSample.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> VideoSample {
        return try VideoSample.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> VideoSample {
        return try VideoSample.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> VideoSample {
        return try VideoSample.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> VideoSample {
        return try VideoSample.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> VideoSample {
        return try VideoSample.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "image": return self.image
        default: return nil
        }
    }
}
extension VideoSample.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "image": return self.image
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "image":
                guard let newSubscriptValue = newSubscriptValue as? Image else {
                    return
                }
                self.image = newSubscriptValue
            default: return
            }
        }
    }
}
extension AudioSample: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<AudioSample> {
        var mergedArray = Array<AudioSample>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> AudioSample? {
        return try AudioSample.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> AudioSample {
        return try AudioSample.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> AudioSample {
        return try AudioSample.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> AudioSample {
        return try AudioSample.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> AudioSample {
        return try AudioSample.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> AudioSample {
        return try AudioSample.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> AudioSample {
        return try AudioSample.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "image": return self.image
        default: return nil
        }
    }
}
extension AudioSample.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "image": return self.image
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "image":
                guard let newSubscriptValue = newSubscriptValue as? Image else {
                    return
                }
                self.image = newSubscriptValue
            default: return
            }
        }
    }
}
extension Av: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Av> {
        var mergedArray = Array<Av>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Av? {
        return try Av.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Av {
        return try Av.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Av {
        return try Av.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Av {
        return try Av.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Av {
        return try Av.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Av {
        return try Av.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Av {
        return try Av.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "video": return self.video
        case "audio": return self.audio
        default: return nil
        }
    }
}
extension Av.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "video": return self.video
            case "audio": return self.audio
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "video":
                guard let newSubscriptValue = newSubscriptValue as? VideoSample else {
                    return
                }
                self.video = newSubscriptValue
            case "audio":
                guard let newSubscriptValue = newSubscriptValue as? AudioSample else {
                    return
                }
                self.audio = newSubscriptValue
            default: return
            }
        }
    }
}
extension Avsession: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Avsession> {
        var mergedArray = Array<Avsession>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Avsession? {
        return try Avsession.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Avsession {
        return try Avsession.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Avsession {
        return try Avsession.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Avsession {
        return try Avsession.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Avsession {
        return try Avsession.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Avsession {
        return try Avsession.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Avsession {
        return try Avsession.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "sid": return self.sid
        case "gid": return self.gid
        case "active": return self.active
        case "data": return self.data
        default: return nil
        }
    }
}
extension Avsession.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "sid": return self.sid
            case "gid": return self.gid
            case "active": return self.active
            case "data": return self.data
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "sid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sid = newSubscriptValue
            case "gid":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.gid = newSubscriptValue
            case "active":
                guard let newSubscriptValue = newSubscriptValue as? Bool else {
                    return
                }
                self.active = newSubscriptValue
            case "data":
                guard let newSubscriptValue = newSubscriptValue as? Data else {
                    return
                }
                self.data = newSubscriptValue
            default: return
            }
        }
    }
}
extension Avquality: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Avquality> {
        var mergedArray = Array<Avquality>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Avquality? {
        return try Avquality.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Avquality {
        return try Avquality.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Avquality {
        return try Avquality.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Avquality {
        return try Avquality.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Avquality {
        return try Avquality.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Avquality {
        return try Avquality.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Avquality {
        return try Avquality.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "diff": return self.diff
        default: return nil
        }
    }
}
extension Avquality.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "diff": return self.diff
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "diff":
                guard let newSubscriptValue = newSubscriptValue as? Int32 else {
                    return
                }
                self.diff = newSubscriptValue
            default: return
            }
        }
    }
}
extension Haber: GeneratedMessageProtocol {
    public class func parseArrayDelimitedFrom(inputStream: InputStream) throws -> Array<Haber> {
        var mergedArray = Array<Haber>()
        while let value = try parseDelimitedFrom(inputStream: inputStream) {
          mergedArray.append(value)
        }
        return mergedArray
    }
    public class func parseDelimitedFrom(inputStream: InputStream) throws -> Haber? {
        return try Haber.Builder().mergeDelimitedFrom(inputStream: inputStream)?.build()
    }
    public class func parseFrom(data: Data) throws -> Haber {
        return try Haber.Builder().mergeFrom(data: data, extensionRegistry:WireRoot.default.extensionRegistry).build()
    }
    public class func parseFrom(data: Data, extensionRegistry:ExtensionRegistry) throws -> Haber {
        return try Haber.Builder().mergeFrom(data: data, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(inputStream: InputStream) throws -> Haber {
        return try Haber.Builder().mergeFrom(inputStream: inputStream).build()
    }
    public class func parseFrom(inputStream: InputStream, extensionRegistry:ExtensionRegistry) throws -> Haber {
        return try Haber.Builder().mergeFrom(inputStream: inputStream, extensionRegistry:extensionRegistry).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream) throws -> Haber {
        return try Haber.Builder().mergeFrom(codedInputStream: codedInputStream).build()
    }
    public class func parseFrom(codedInputStream: CodedInputStream, extensionRegistry:ExtensionRegistry) throws -> Haber {
        return try Haber.Builder().mergeFrom(codedInputStream: codedInputStream, extensionRegistry:extensionRegistry).build()
    }
    public subscript(key: String) -> Any? {
        switch key {
        case "version": return self.version
        case "sessionId": return self.sessionId
        case "from": return self.from
        case "to": return self.to
        case "which": return self.which
        case "login": return self.login
        case "contacts": return self.contacts
        case "text": return self.text
        case "file": return self.file
        case "call": return self.call
        case "av": return self.av
        case "audioSession": return self.audioSession
        case "videoSession": return self.videoSession
        case "avQuality": return self.avQuality
        default: return nil
        }
    }
}
extension Haber.Builder: GeneratedMessageBuilderProtocol {
    public subscript(key: String) -> Any? {
        get { 
            switch key {
            case "version": return self.version
            case "sessionId": return self.sessionId
            case "from": return self.from
            case "to": return self.to
            case "which": return self.which
            case "login": return self.login
            case "contacts": return self.contacts
            case "text": return self.text
            case "file": return self.file
            case "call": return self.call
            case "av": return self.av
            case "audioSession": return self.audioSession
            case "videoSession": return self.videoSession
            case "avQuality": return self.avQuality
            default: return nil
            }
        }
        set (newSubscriptValue) { 
            switch key {
            case "version":
                guard let newSubscriptValue = newSubscriptValue as? UInt32 else {
                    return
                }
                self.version = newSubscriptValue
            case "sessionId":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.sessionId = newSubscriptValue
            case "from":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.from = newSubscriptValue
            case "to":
                guard let newSubscriptValue = newSubscriptValue as? String else {
                    return
                }
                self.to = newSubscriptValue
            case "which":
                guard let newSubscriptValue = newSubscriptValue as? Haber.Which else {
                    return
                }
                self.which = newSubscriptValue
            case "login":
                guard let newSubscriptValue = newSubscriptValue as? Login else {
                    return
                }
                self.login = newSubscriptValue
            case "contacts":
                guard let newSubscriptValue = newSubscriptValue as? Array<Contact> else {
                    return
                }
                self.contacts = newSubscriptValue
            case "text":
                guard let newSubscriptValue = newSubscriptValue as? Text else {
                    return
                }
                self.text = newSubscriptValue
            case "file":
                guard let newSubscriptValue = newSubscriptValue as? File else {
                    return
                }
                self.file = newSubscriptValue
            case "call":
                guard let newSubscriptValue = newSubscriptValue as? Call else {
                    return
                }
                self.call = newSubscriptValue
            case "av":
                guard let newSubscriptValue = newSubscriptValue as? Av else {
                    return
                }
                self.av = newSubscriptValue
            case "audioSession":
                guard let newSubscriptValue = newSubscriptValue as? Avsession else {
                    return
                }
                self.audioSession = newSubscriptValue
            case "videoSession":
                guard let newSubscriptValue = newSubscriptValue as? Avsession else {
                    return
                }
                self.videoSession = newSubscriptValue
            case "avQuality":
                guard let newSubscriptValue = newSubscriptValue as? Avquality else {
                    return
                }
                self.avQuality = newSubscriptValue
            default: return
            }
        }
    }
}

// @@protoc_insertion_point(global_scope)
